# Feature Overview

* **Reactive Web Components**: Simplifies front-end web development with `ReactiveElement`. This is done through [Observable Properties](observable_property.md). They are properties of a `ReactiveElement` instance that are automatically observed for changes. When a change occurs, the `ReactiveElement` instance is notified and can react accordingly by re-rendering the component. Observable properties support deep updates, array changes, and reactive attributes, making it easier to manage dynamic content. Lastly, this removes the boilerplate of `signal()`, `setState()`, or `reactive()` that you might find in other libraries.
* **Async State Management**: Easily manage server data. Our library provides a simple API for fetching and updating data with [`query` and `mutation`](async_state_management.md). Use the `query` method to fetch and cache data, with options to control how often it refreshes. The `mutation` method lets you update data and immediately reflect those changes in the UI, providing a smooth experience without waiting for server responses.
* **Cross-component State Management with  Stores**: Share state across different components with ease using a single store using [`cami.store`](client_state_management.md). By default, this uses `localStorage` to persist state across page refreshes. This is useful for storing user preferences, authentication tokens, and other data that needs to be shared across components. This is also useful for storing data that needs to be shared across tabs.
* **Streams & Functional Reactive Programming (FRP)**: Handle asynchronous events gracefully with [Observable Streams](streams.md). They offer powerful functions like `map`, `filter`, `flatMap`, and `debounce` to process events in a sophisticated yet manageable way, for clean & declarative code.


<h2>Internals that You Don't Need to Worry About</h2>

* **Caching, Refetching, and Stale Data Handling for Server-side State**: Keep your data fresh with automatic caching and refetching. Our library automatically caches data and refetches it when needed, so you don't have to worry about stale data.
* **Automatic Expiry of Client-Side State**: Keep your client-side state fresh with automatic expiry. Our store automatically expires state after a configurable duration (default is 24 hours), so you don't have to worry about stale data.
* **Dependency Tracking**: Keep your app's data in sync automatically. Our dependency tracker observes the relationships between your data and updates them as needed, so you can focus on writing the logic that matters.
* **Automatic Disposal & Garbage Collection**: Avoid memory leaks with automatic disposal. Our library automatically disposes of streams, dependencies, and effects when they are no longer needed, so you don't have to worry about it.
