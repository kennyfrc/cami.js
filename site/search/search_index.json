{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cami","text":"<p>Cami.js is a minimalist yet powerful toolkit to build reactive web components in web applications. No build step required.</p> <p>While minimalist, it has features you'd expect from a modern web framework, such as reactive web components, async state management, streams, and cross-component state management, ideal for creating internal tools, dashboards, and other web applications.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>In any HTML file, just add the CDN link:</p> <pre><code>&lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Then in your JavaScript file, import <code>html</code> and <code>ReactiveElement</code>. <code>html</code> is for creating HTML templates and <code>ReactiveElement</code> is an extension of <code>HTMLElement</code> that automatically defines observables without any boilerplate.</p> <pre><code>&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n  &lt;!-- ... --&gt;\n&lt;/script&gt;\n</code></pre> <p>To create a simple counter, extend <code>ReactiveElement</code> and define a <code>count</code> property:</p> <pre><code>  class CounterElement extends ReactiveElement {\n    count = 0\n    // ...\n  }\n</code></pre> <p>Then define a <code>template</code> method that returns an HTML template using the <code>html</code> function:</p> <pre><code>template() {\n  return html`\n    &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n    &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n    &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n  `;\n}\n</code></pre> <p>Register your custom element.</p> <pre><code>customElements.define('counter-component', CounterElement);\n</code></pre> <p>Finally, add the element to your HTML file:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n</code></pre> <p>This is how everything comes together:</p> <pre><code>&lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0\n\n    template() {\n      return html`\n        &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"#demo","title":"Demo","text":"<p>And here's how it would look like:</p> Counter"},{"location":"features/","title":"Features","text":"<ul> <li>Reactive Web Components: Simplify your web development with <code>ReactiveElement</code>, which extends the standard <code>HTMLElement</code>. It automatically sets up reactive properties, so you don't have to write the usual boilerplate code. This feature supports complex scenarios like deep updates, array changes, and reactive attributes, making it easier to manage dynamic content.</li> <li>Async State Management: Easily manage server data with our async tools. Use the <code>query</code> method to fetch and cache data, with options to control how often it refreshes. The <code>mutation</code> method lets you update data and immediately reflect those changes in the UI, providing a smooth experience without waiting for server responses.</li> <li>Streams &amp; Functional Reactive Programming (FRP): Handle asynchronous events gracefully with Observable Streams. They offer powerful functions like <code>map</code>, <code>filter</code>, and <code>debounce</code> to process events in a sophisticated yet manageable way, perfect for writing clean, reactive code.</li> <li>Cross-component State Management with a Singleton Store: Share state across different components with ease using a single store. This approach is compatible with Redux DevTools, giving you powerful debugging capabilities.</li> <li>Dependency Tracking: Keep your app's data in sync automatically. Our dependency tracker observes the relationships between your data and updates them as needed, so you can focus on writing the logic that matters.</li> </ul>"},{"location":"features/#reactive-web-components","title":"Reactive Web Components","text":"<p>Let's take the example of creating a counter component. In contrast to other frameworks where you might need to define a counter with something like <code>count = signal(0)</code> or <code>count = ref(0)</code>, and then retrieve the value with <code>count()</code> or <code>count.value</code>, Cami.js simplifies this process significantly.</p> <p>You can directly define <code>count = 0</code> within your <code>CounterElement</code> class and access it just like a regular JavaScript variable.</p> <p>Define a <code>CounterElement</code> class that extends <code>ReactiveElement</code> and define a <code>count</code> property initialized to 0:</p> <pre><code>class CounterElement extends ReactiveElement {\n  count = 0;\n  // ...\n}\n</code></pre> <p>Then define a <code>template</code> method that returns an HTML template using the <code>html</code> function:</p> <pre><code>template() {\n  return html`\n    &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n    &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n    &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n  `;\n}\n</code></pre> <p>Finally, register your custom element.</p> <pre><code>customElements.define('counter-component', CounterElement);\n</code></pre> <p>Add the element to your HTML file:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n</code></pre> <p>This is how everything comes together:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0;\n    template() {\n      return html`\n        &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"features/#live-demo-of-reactive-web-components-simple-counter","title":"Live Demo of Reactive Web Components (Simple Counter)","text":"<p>Now, when you load your HTML file, you will see a counter with two buttons to increment and decrement the count. The count is displayed and updated in real-time as you click the buttons.</p>"},{"location":"features/#async-state-management","title":"Async State Management","text":"<p>Cami provides a powerful async state management system that allows components to fetch and manage asynchronous data with ease. Here's how it works:</p>"},{"location":"features/#queries","title":"Queries","text":"<p>Queries are used to fetch data asynchronously and serve it to your components. They are defined with a <code>queryKey</code>, a unique identifier for the query's data in the internal cache, and a <code>queryFn</code>, a function that fetches the data. The result of a query is an observable object that automatically updates its <code>data</code>, <code>status</code>, and <code>error</code> keys based on the query's execution, allowing you to declaratively render UI based on the state of the asynchronous operation.</p> <p>Here's an example of defining a query in a component and using it to render UI:</p> <pre><code>posts = this.query({\n  queryKey: [\"posts\"],\n  queryFn: () =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\").then(res =&gt; res.json()),\n  staleTime: 1000 * 60 * 5 // Optional: data is considered fresh for 5 minutes\n});\n\ntemplate() {\n  if (this.posts.status === \"loading\") {\n    return html`&lt;div&gt;Loading...&lt;/div&gt;`;\n  }\n\n  if (this.posts.status === \"error\") {\n    return html`&lt;div&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n  }\n\n  if (this.posts.data) {\n    return html`\n      &lt;ul&gt;\n        ${this.posts.data.map(post =&gt; html`\n          &lt;li&gt;\n            &lt;h2&gt;${post.title}&lt;/h2&gt;\n            &lt;p&gt;${post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        `)}\n      &lt;/ul&gt;\n    `;\n  }\n}\n</code></pre> <p>Queries automatically refetch data to prevent it from becoming stale. However, you can control this behavior with the <code>staleTime</code> parameter, which defines how long the data should remain fresh before a refetch is required. The observable object returned by the query allows for a reactive connection between the data and the component's template, enabling the UI to update automatically when the query's state changes.</p> <p>When a component is added to the DOM, we can start fetching data by using the <code>onConnect()</code> method. This method is similar to the <code>connectedCallback()</code> used in Web Components, which you can read more about on MDN. Inside <code>onConnect()</code>, we call a function like <code>fetchPosts()</code> to load our data.</p> <p>For displaying the data, we can create a separate method like <code>renderPosts()</code> and call it inside our <code>template()</code> method. This helps us keep our code organized and makes it easier to manage different parts of our component.</p> <p>Here's how you can structure the component:</p> <pre><code>class BlogPostsElement extends ReactiveElement {\n  posts = {}\n\n  onConnect() {\n    this.fetchPosts();\n  }\n\n  fetchPosts() {\n    this.posts = this.query({\n      queryKey: ['posts', { limit }],\n      queryFn: () =&gt; fetch(`https://jsonplaceholder.typicode.com/posts?_limit=5`).then(res =&gt; res.json())\n    });\n  }\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.fetchPosts()}&gt;Refetch Posts&lt;/button&gt;\n      ${this.renderPosts()}\n    `;\n  }\n\n  renderPosts() {\n    if (this.posts.status === \"loading\") {\n      return html`&lt;div class=\"md-loader\"&gt;Loading...&lt;/div&gt;`;\n    }\n\n    if (this.posts.status === \"error\") {\n      return html`&lt;div class=\"md-error\"&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n    }\n\n    if (this.posts.data) {\n      return html`\n        &lt;div class=\"md-card\"&gt;\n          &lt;ul class=\"md-list\"&gt;\n            ${this.posts.data.map(post =&gt; html`\n              &lt;li class=\"md-list-item\"&gt;\n                &lt;h5 class=\"md-title\"&gt;${post.title}&lt;/h5&gt;\n                &lt;p class=\"md-body-1\"&gt;${post.body}&lt;/p&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        &lt;/div&gt;\n      `;\n    }\n  }\n}\n</code></pre> <p>This way, the <code>onConnect()</code> method is used to start the data fetching process, and the <code>renderPosts()</code> method is used to handle the display of the posts, keeping the code clean and easy to understand.</p>"},{"location":"features/#live-demo-of-async-state-management-blog-posts-query","title":"Live Demo of Async State Management (Blog Posts - Query)","text":"<p>Below is a live demo of the component in action. The only change is that we're fetching a random number of posts between 1 and 5 just so you can see states change.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/#mutations","title":"Mutations","text":"<p>Mutations are used to modify server-side data and reflect those changes in the UI. They are defined with a <code>mutationFn</code>, which performs the update.</p> <p>Here's an example of defining a mutation in a component:</p> <pre><code>addPost = this.mutation({\n  mutationFn: (newPost) =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    method: \"POST\",\n    body: JSON.stringify(newPost),\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\"\n    }\n  }).then(res =&gt; res.json())\n});\n</code></pre> <p>This mutation submits a POST request to the server, and the component's UI can declaratively show various loading and error states. For example, you can display a loading message while the request is pending and an error message if the request fails, as shown below:</p> <pre><code>if (this.addPost.status === \"pending\") {\n  return html`\n    &lt;div&gt;Adding post...&lt;/div&gt;\n  `;\n}\n\nif (this.addPost.status === \"error\") {\n  return html`&lt;div&gt;Error: ${this.addPost.error.message}&lt;/div&gt;`;\n}\n</code></pre> <p>By using mutations, Cami enables developers to handle server-side updates in a consistent and powerful way, similar to how queries are used for fetching data.</p>"},{"location":"features/#live-demo-of-async-state-management-blog-posts-with-mutations","title":"Live Demo of Async State Management (Blog Posts - With Mutations)","text":"<p>This live demo includes a form to submit a new post, which uses a mutation to update the server-side data. The mutation is defined in the <code>BlogPostsElement</code> class, and it handles the post submission process. The UI reflects the state of the mutation, showing a loading message while the request is pending and an error message if the request fails.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"blog/","title":"Blog","text":"<p>tbc</p>"},{"location":"features/async_state_management/","title":"Async state management","text":"<p>Cami provides a powerful async state management system that allows components to fetch and manage asynchronous data with ease. Here's how it works:</p>"},{"location":"features/async_state_management/#queries","title":"Queries","text":"<p>Queries are used to fetch data asynchronously and serve it to your components. They are defined with a <code>queryKey</code>, a unique identifier for the query's data in the internal cache, and a <code>queryFn</code>, a function that fetches the data. The result of a query is an observable object that automatically updates its <code>data</code>, <code>status</code>, and <code>error</code> keys based on the query's execution, allowing you to declaratively render UI based on the state of the asynchronous operation.</p> <p>Here's an example of defining a query in a component and using it to render UI:</p> <pre><code>posts = this.query({\n  queryKey: [\"posts\"],\n  queryFn: () =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\").then(res =&gt; res.json()),\n  staleTime: 1000 * 60 * 5 // Optional: data is considered fresh for 5 minutes\n});\n\ntemplate() {\n  if (this.posts.status === \"loading\") {\n    return html`&lt;div&gt;Loading...&lt;/div&gt;`;\n  }\n\n  if (this.posts.status === \"error\") {\n    return html`&lt;div&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n  }\n\n  if (this.posts.data) {\n    return html`\n      &lt;ul&gt;\n        ${this.posts.data.map(post =&gt; html`\n          &lt;li&gt;\n            &lt;h2&gt;${post.title}&lt;/h2&gt;\n            &lt;p&gt;${post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        `)}\n      &lt;/ul&gt;\n    `;\n  }\n}\n</code></pre> <p>Queries automatically refetch data to prevent it from becoming stale. However, you can control this behavior with the <code>staleTime</code> parameter, which defines how long the data should remain fresh before a refetch is required. The observable object returned by the query allows for a reactive connection between the data and the component's template, enabling the UI to update automatically when the query's state changes.</p> <p>When a component is added to the DOM, we can start fetching data by using the <code>onConnect()</code> method. This method is similar to the <code>connectedCallback()</code> used in Web Components, which you can read more about on MDN. Inside <code>onConnect()</code>, we call a function like <code>fetchPosts()</code> to load our data.</p> <p>For displaying the data, we can create a separate method like <code>renderPosts()</code> and call it inside our <code>template()</code> method. This helps us keep our code organized and makes it easier to manage different parts of our component.</p> <p>Here's how you can structure the component:</p> <pre><code>class BlogPostsElement extends ReactiveElement {\n  posts = {}\n\n  onConnect() {\n    this.fetchPosts();\n  }\n\n  fetchPosts() {\n    this.posts = this.query({\n      queryKey: ['posts', { limit }],\n      queryFn: () =&gt; fetch(`https://jsonplaceholder.typicode.com/posts?_limit=5`).then(res =&gt; res.json())\n    });\n  }\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.fetchPosts()}&gt;Refetch Posts&lt;/button&gt;\n      ${this.renderPosts()}\n    `;\n  }\n\n  renderPosts() {\n    if (this.posts.status === \"loading\") {\n      return html`&lt;div class=\"md-loader\"&gt;Loading...&lt;/div&gt;`;\n    }\n\n    if (this.posts.status === \"error\") {\n      return html`&lt;div class=\"md-error\"&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n    }\n\n    if (this.posts.data) {\n      return html`\n        &lt;div class=\"md-card\"&gt;\n          &lt;ul class=\"md-list\"&gt;\n            ${this.posts.data.map(post =&gt; html`\n              &lt;li class=\"md-list-item\"&gt;\n                &lt;h5 class=\"md-title\"&gt;${post.title}&lt;/h5&gt;\n                &lt;p class=\"md-body-1\"&gt;${post.body}&lt;/p&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        &lt;/div&gt;\n      `;\n    }\n  }\n}\n</code></pre> <p>This way, the <code>onConnect()</code> method is used to start the data fetching process, and the <code>renderPosts()</code> method is used to handle the display of the posts, keeping the code clean and easy to understand.</p>"},{"location":"features/async_state_management/#live-demo-of-async-state-management-blog-posts-query","title":"Live Demo of Async State Management (Blog Posts - Query)","text":"<p>Below is a live demo of the component in action. The only change is that we're fetching a random number of posts between 1 and 5 just so you can see states change.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/async_state_management/#mutations","title":"Mutations","text":"<p>Mutations are used to modify server-side data and reflect those changes in the UI. They are defined with a <code>mutationFn</code>, which performs the update.</p> <p>Here's an example of defining a mutation in a component:</p> <pre><code>addPost = this.mutation({\n  mutationFn: (newPost) =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    method: \"POST\",\n    body: JSON.stringify(newPost),\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\"\n    }\n  }).then(res =&gt; res.json())\n});\n</code></pre> <p>This mutation submits a POST request to the server, and the component's UI can declaratively show various loading and error states. For example, you can display a loading message while the request is pending and an error message if the request fails, as shown below:</p> <pre><code>if (this.addPost.status === \"pending\") {\n  return html`\n    &lt;div&gt;Adding post...&lt;/div&gt;\n  `;\n}\n\nif (this.addPost.status === \"error\") {\n  return html`&lt;div&gt;Error: ${this.addPost.error.message}&lt;/div&gt;`;\n}\n</code></pre> <p>By using mutations, Cami enables developers to handle server-side updates in a consistent and powerful way, similar to how queries are used for fetching data.</p>"},{"location":"features/async_state_management/#live-demo-of-async-state-management-blog-posts-with-mutations","title":"Live Demo of Async State Management (Blog Posts - With Mutations)","text":"<p>This live demo includes a form to submit a new post, which uses a mutation to update the server-side data. The mutation is defined in the <code>BlogPostsElement</code> class, and it handles the post submission process. The UI reflects the state of the mutation, showing a loading message while the request is pending and an error message if the request fails.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/features/","title":"Features","text":"<ul> <li>Reactive Web Components: Simplify your web development with <code>ReactiveElement</code>, which extends the standard <code>HTMLElement</code>. It automatically sets up reactive properties, so you don't have to write the usual boilerplate code. This feature supports complex scenarios like deep updates, array changes, and reactive attributes, making it easier to manage dynamic content.</li> <li>Async State Management: Easily manage server data with our async tools. Use the <code>query</code> method to fetch and cache data, with options to control how often it refreshes. The <code>mutation</code> method lets you update data and immediately reflect those changes in the UI, providing a smooth experience without waiting for server responses.</li> <li>Streams &amp; Functional Reactive Programming (FRP): Handle asynchronous events gracefully with Observable Streams. They offer powerful functions like <code>map</code>, <code>filter</code>, and <code>debounce</code> to process events in a sophisticated yet manageable way, perfect for writing clean, reactive code.</li> <li>Cross-component State Management with a Singleton Store: Share state across different components with ease using a single store. This approach is compatible with Redux DevTools, giving you powerful debugging capabilities.</li> <li>Dependency Tracking: Keep your app's data in sync automatically. Our dependency tracker observes the relationships between your data and updates them as needed, so you can focus on writing the logic that matters.</li> </ul>"},{"location":"features/features/#reactive-web-components","title":"Reactive Web Components","text":"<p>Let's take the example of creating a counter component. In contrast to other frameworks where you might need to define a counter with something like <code>count = signal(0)</code> or <code>count = ref(0)</code>, and then retrieve the value with <code>count()</code> or <code>count.value</code>, Cami.js simplifies this process significantly.</p> <p>You can directly define <code>count = 0</code> within your <code>CounterElement</code> class and access it just like a regular JavaScript variable.</p> <p>Define a <code>CounterElement</code> class that extends <code>ReactiveElement</code> and define a <code>count</code> property initialized to 0:</p> <pre><code>class CounterElement extends ReactiveElement {\n  count = 0;\n  // ...\n}\n</code></pre> <p>Then define a <code>template</code> method that returns an HTML template using the <code>html</code> function:</p> <pre><code>template() {\n  return html`\n    &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n    &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n    &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n  `;\n}\n</code></pre> <p>Finally, register your custom element.</p> <pre><code>customElements.define('counter-component', CounterElement);\n</code></pre> <p>Add the element to your HTML file:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n</code></pre> <p>This is how everything comes together:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0;\n    template() {\n      return html`\n        &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"features/features/#live-demo-of-reactive-web-components-simple-counter","title":"Live Demo of Reactive Web Components (Simple Counter)","text":"<p>Now, when you load your HTML file, you will see a counter with two buttons to increment and decrement the count. The count is displayed and updated in real-time as you click the buttons.</p>"},{"location":"features/features/#async-state-management","title":"Async State Management","text":"<p>Cami provides a powerful async state management system that allows components to fetch and manage asynchronous data with ease. Here's how it works:</p>"},{"location":"features/features/#queries","title":"Queries","text":"<p>Queries are used to fetch data asynchronously and serve it to your components. They are defined with a <code>queryKey</code>, a unique identifier for the query's data in the internal cache, and a <code>queryFn</code>, a function that fetches the data. The result of a query is an observable object that automatically updates its <code>data</code>, <code>status</code>, and <code>error</code> keys based on the query's execution, allowing you to declaratively render UI based on the state of the asynchronous operation.</p> <p>Here's an example of defining a query in a component and using it to render UI:</p> <pre><code>posts = this.query({\n  queryKey: [\"posts\"],\n  queryFn: () =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\").then(res =&gt; res.json()),\n  staleTime: 1000 * 60 * 5 // Optional: data is considered fresh for 5 minutes\n});\n\ntemplate() {\n  if (this.posts.status === \"loading\") {\n    return html`&lt;div&gt;Loading...&lt;/div&gt;`;\n  }\n\n  if (this.posts.status === \"error\") {\n    return html`&lt;div&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n  }\n\n  if (this.posts.data) {\n    return html`\n      &lt;ul&gt;\n        ${this.posts.data.map(post =&gt; html`\n          &lt;li&gt;\n            &lt;h2&gt;${post.title}&lt;/h2&gt;\n            &lt;p&gt;${post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        `)}\n      &lt;/ul&gt;\n    `;\n  }\n}\n</code></pre> <p>Queries automatically refetch data to prevent it from becoming stale. However, you can control this behavior with the <code>staleTime</code> parameter, which defines how long the data should remain fresh before a refetch is required. The observable object returned by the query allows for a reactive connection between the data and the component's template, enabling the UI to update automatically when the query's state changes.</p> <p>When a component is added to the DOM, we can start fetching data by using the <code>onConnect()</code> method. This method is similar to the <code>connectedCallback()</code> used in Web Components, which you can read more about on MDN. Inside <code>onConnect()</code>, we call a function like <code>fetchPosts()</code> to load our data.</p> <p>For displaying the data, we can create a separate method like <code>renderPosts()</code> and call it inside our <code>template()</code> method. This helps us keep our code organized and makes it easier to manage different parts of our component.</p> <p>Here's how you can structure the component:</p> <pre><code>class BlogPostsElement extends ReactiveElement {\n  posts = {}\n\n  onConnect() {\n    this.fetchPosts();\n  }\n\n  fetchPosts() {\n    this.posts = this.query({\n      queryKey: ['posts', { limit }],\n      queryFn: () =&gt; fetch(`https://jsonplaceholder.typicode.com/posts?_limit=5`).then(res =&gt; res.json())\n    });\n  }\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.fetchPosts()}&gt;Refetch Posts&lt;/button&gt;\n      ${this.renderPosts()}\n    `;\n  }\n\n  renderPosts() {\n    if (this.posts.status === \"loading\") {\n      return html`&lt;div class=\"md-loader\"&gt;Loading...&lt;/div&gt;`;\n    }\n\n    if (this.posts.status === \"error\") {\n      return html`&lt;div class=\"md-error\"&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n    }\n\n    if (this.posts.data) {\n      return html`\n        &lt;div class=\"md-card\"&gt;\n          &lt;ul class=\"md-list\"&gt;\n            ${this.posts.data.map(post =&gt; html`\n              &lt;li class=\"md-list-item\"&gt;\n                &lt;h5 class=\"md-title\"&gt;${post.title}&lt;/h5&gt;\n                &lt;p class=\"md-body-1\"&gt;${post.body}&lt;/p&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        &lt;/div&gt;\n      `;\n    }\n  }\n}\n</code></pre> <p>This way, the <code>onConnect()</code> method is used to start the data fetching process, and the <code>renderPosts()</code> method is used to handle the display of the posts, keeping the code clean and easy to understand.</p>"},{"location":"features/features/#live-demo-of-async-state-management-blog-posts-query","title":"Live Demo of Async State Management (Blog Posts - Query)","text":"<p>Below is a live demo of the component in action. The only change is that we're fetching a random number of posts between 1 and 5 just so you can see states change.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/features/#mutations","title":"Mutations","text":"<p>Mutations are used to modify server-side data and reflect those changes in the UI. They are defined with a <code>mutationFn</code>, which performs the update.</p> <p>Here's an example of defining a mutation in a component:</p> <pre><code>addPost = this.mutation({\n  mutationFn: (newPost) =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    method: \"POST\",\n    body: JSON.stringify(newPost),\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\"\n    }\n  }).then(res =&gt; res.json())\n});\n</code></pre> <p>This mutation submits a POST request to the server, and the component's UI can declaratively show various loading and error states. For example, you can display a loading message while the request is pending and an error message if the request fails, as shown below:</p> <pre><code>if (this.addPost.status === \"pending\") {\n  return html`\n    &lt;div&gt;Adding post...&lt;/div&gt;\n  `;\n}\n\nif (this.addPost.status === \"error\") {\n  return html`&lt;div&gt;Error: ${this.addPost.error.message}&lt;/div&gt;`;\n}\n</code></pre> <p>By using mutations, Cami enables developers to handle server-side updates in a consistent and powerful way, similar to how queries are used for fetching data.</p>"},{"location":"features/features/#live-demo-of-async-state-management-blog-posts-with-mutations","title":"Live Demo of Async State Management (Blog Posts - With Mutations)","text":"<p>This live demo includes a form to submit a new post, which uses a mutation to update the server-side data. The mutation is defined in the <code>BlogPostsElement</code> class, and it handles the post submission process. The UI reflects the state of the mutation, showing a loading message while the request is pending and an error message if the request fails.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/reactive_web_components/","title":"Reactive web components","text":"<p>Let's take the example of creating a counter component. In contrast to other frameworks where you might need to define a counter with something like <code>count = signal(0)</code> or <code>count = ref(0)</code>, and then retrieve the value with <code>count()</code> or <code>count.value</code>, Cami.js simplifies this process significantly.</p> <p>You can directly define <code>count = 0</code> within your <code>CounterElement</code> class and access it just like a regular JavaScript variable.</p> <p>Define a <code>CounterElement</code> class that extends <code>ReactiveElement</code> and define a <code>count</code> property initialized to 0:</p> <pre><code>class CounterElement extends ReactiveElement {\n  count = 0;\n  // ...\n}\n</code></pre> <p>Then define a <code>template</code> method that returns an HTML template using the <code>html</code> function:</p> <pre><code>template() {\n  return html`\n    &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n    &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n    &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n  `;\n}\n</code></pre> <p>Finally, register your custom element.</p> <pre><code>customElements.define('counter-component', CounterElement);\n</code></pre> <p>Add the element to your HTML file:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n</code></pre> <p>This is how everything comes together:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0;\n    template() {\n      return html`\n        &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"features/reactive_web_components/#live-demo-of-reactive-web-components-simple-counter","title":"Live Demo of Reactive Web Components (Simple Counter)","text":"<p>Now, when you load your HTML file, you will see a counter with two buttons to increment and decrement the count. The count is displayed and updated in real-time as you click the buttons.</p>"},{"location":"getting_started/","title":"Index","text":"<p>tbc</p>"}]}