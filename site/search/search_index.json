{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cami","text":"<p>Cami.js is a minimalist yet powerful toolkit for interactive islands in web applications. No build step required.</p> <p>It has features you'd expect from a modern UI framework, such as reactive web components, async state management, streams, and cross-component state management.</p> <p>Note that Cami specializes in bringing rich interactivity to your web application. As such, it's meant to be used alongside a backend framework such as FastAPI, Rails, Sinatra, or any server really that responds with HTML. Just paste in Cami's CDN link (or import the bundle) and you'll get the power of many modern UI frameworks without it taking over your workflow. Just progressively enhance your HTML with Cami web components.</p> <p>Core concepts are explained here. Learn by example here. API Reference is available here.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>In any HTML file, just add the CDN link:</p> <pre><code>&lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Then in your JavaScript file, import <code>html</code> and <code>ReactiveElement</code>. <code>html</code> is for creating HTML templates and <code>ReactiveElement</code> is an extension of <code>HTMLElement</code> that automatically defines observables without any boilerplate.</p> <pre><code>&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n  &lt;!-- ... --&gt;\n&lt;/script&gt;\n</code></pre> <p>To create a simple counter, extend <code>ReactiveElement</code> and define a <code>count</code> property:</p> <pre><code>  class CounterElement extends ReactiveElement {\n    count = 0\n    // ...\n  }\n</code></pre> <p>Then define a <code>template</code> method that returns an HTML template using the <code>html</code> function:</p> <pre><code>template() {\n  return html`\n    &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n    &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n    &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n  `;\n}\n</code></pre> <p>Register your custom element.</p> <pre><code>customElements.define('counter-component', CounterElement);\n</code></pre> <p>Finally, add the element to your HTML file:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n</code></pre> <p>This is how everything comes together:</p> <pre><code>&lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0\n\n    template() {\n      return html`\n        &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"#demo","title":"Demo","text":"<p>And here's how it would look like:</p> Counter"},{"location":"api/","title":"API Index","text":"<p>Here is a list of the main functionalities provided by Cami.js:</p> <ul> <li>Reactive Element (Core): An extension of <code>HTMLElement</code> that automatically defines observables without any boilerplate.</li> <li>Console Functions (Utility): A set of utility functions for logging and debugging.</li> <li>HTTP (Utility): A set of functions for making HTTP requests</li> <li>Observable State (Primitive): A class that extends the Observable class and adds methods for updating the value of the observable.</li> <li>Observable Store (Primitive): A store that holds the state of your application and allows you to manage it in a reactive way.</li> <li>Observable Stream (Primitive): A class that provides a way to handle asynchronous data streams.</li> <li>Observable (Primitive): The base class for creating observables.</li> </ul>"},{"location":"api/console_functions/","title":"Console Functions","text":"<p>The following functions can be invoked in the developer tools console. When you import from the IIFE bundle, these functions are available on the global <code>cami</code> object. When you import from the ESM bundle, these functions are available on the <code>cami</code> object.</p>"},{"location":"api/console_functions/#functions","title":"Functions","text":"cami.debug.enable() \u21d2 <code>void</code> <p>This function enables logging.</p> cami.debug.disable() \u21d2 <code>void</code> <p>This function disables logging. This is the default setting.</p> cami.events.enable() \u21d2 <code>void</code> <p>This function enables event emissions. This emits the `cami:state:change` event. One can then attach an eventListener to the window to capture this event. This is the default setting.</p> cami.events.disable() \u21d2 <code>void</code> <p>This function disables event emissions.</p> <p></p>"},{"location":"api/console_functions/#camidebugenable","title":"cami.debug.enable()","text":"<p>This function enables logging.</p> <p>Example <pre><code>cami.debug.enable();\n</code></pre></p> <p></p>"},{"location":"api/console_functions/#camidebugdisable","title":"cami.debug.disable()","text":"<p>This function disables logging. This is the default setting.</p> <p>Example <pre><code>cami.debug.disable();\n</code></pre></p> <p></p>"},{"location":"api/console_functions/#camieventsenable","title":"cami.events.enable()","text":"<p>This function enables event emissions. This emits the <code>cami:state:change</code> event. One can then attach an eventListener to the window to capture this event. This is the default setting.</p> <p>Example <pre><code>cami.events.enable();\nwindow.addEventListener('cami:state:change', function(e) {\n  console.log('State changed:', e.detail);\n});\n</code></pre></p> <p></p>"},{"location":"api/console_functions/#camieventsdisable","title":"cami.events.disable()","text":"<p>This function disables event emissions.</p> <p>Example <pre><code>cami.events.disable();\n</code></pre></p>"},{"location":"api/http/","title":"HTTP","text":""},{"location":"api/http/#classes","title":"Classes","text":"HTTPStream \u21d0 <code>ObservableStream</code>"},{"location":"api/http/#functions","title":"Functions","text":"http(config) \u21d2 <code>HTTPStream</code> <p>Sends an HTTP request.</p> <p></p>"},{"location":"api/http/#httpstream-observablestream","title":"HTTPStream \u21d0 <code>ObservableStream</code>","text":"<p>Kind: global class Extends: <code>ObservableStream</code> </p> <ul> <li>HTTPStream \u21d0 <code>ObservableStream</code><ul> <li>new HTTPStream()</li> <li>.toJson() \u21d2 <code>Promise</code></li> <li>.on(event, handler) \u21d2 <code>HTTPStream</code></li> </ul> </li> </ul> <p></p>"},{"location":"api/http/#new-httpstream","title":"new HTTPStream()","text":"<p>A class that extends ObservableStream and provides additional methods for handling HTTP requests.</p> <p></p>"},{"location":"api/http/#httpstreamtojson-promise","title":"HTTPStream.toJson() \u21d2 <code>Promise</code>","text":"<p>Converts the response data to JSON.</p> <p>Kind: static method of <code>HTTPStream</code> Returns: <code>Promise</code> - A promise that resolves to the JSON data. Example <pre><code>http('https://api.example.com/data')\n  .toJson()\n  .then(data =&gt; console.log(data))\n  .catch(error =&gt; console.error(error));\n</code></pre> </p>"},{"location":"api/http/#httpstreamonevent-handler-httpstream","title":"HTTPStream.on(event, handler) \u21d2 <code>HTTPStream</code>","text":"<p>Registers an event handler for a specified event.</p> <p>Kind: static method of <code>HTTPStream</code> Returns: <code>HTTPStream</code> - The HTTPStream instance.  </p> Param Type Description event <code>string</code> The event to register the handler for. handler <code>function</code> The handler function. <p></p>"},{"location":"api/http/#httpconfig-httpstream","title":"http(config) \u21d2 <code>HTTPStream</code>","text":"<p>Sends an HTTP request.</p> <p>Kind: global function Returns: <code>HTTPStream</code> - An HTTPStream that resolves to the response data.  </p> Param Type Description config <code>Object</code> | <code>string</code> The configuration object or URL string. <p>Example <pre><code>http('https://api.example.com/data')\n  .tap(data =&gt; console.log(data))\n  .catchError(error =&gt; console.error(error));\n</code></pre></p> <ul> <li>http(config) \u21d2 <code>HTTPStream</code><ul> <li>.get(url, [config]) \u21d2 <code>HTTPStream</code></li> <li>.post(url, [data], [config]) \u21d2 <code>HTTPStream</code></li> <li>.put(url, [data], [config]) \u21d2 <code>HTTPStream</code></li> <li>.patch(url, [data], [config]) \u21d2 <code>HTTPStream</code></li> <li>.delete(url, [config]) \u21d2 <code>HTTPStream</code></li> <li>.sse(url, [config]) \u21d2 <code>HTTPStream</code></li> </ul> </li> </ul> <p></p>"},{"location":"api/http/#httpgeturl-config-httpstream","title":"http.get(url, [config]) \u21d2 <code>HTTPStream</code>","text":"<p>Sends a GET request.</p> <p>Kind: static method of <code>http</code> Returns: <code>HTTPStream</code> - An HTTPStream that resolves to the response data.  </p> Param Type Default Description url <code>string</code> The URL to send the GET request to. [config] <code>Object</code> <code>{}</code> Optional configuration object. <p>Example <pre><code>http.get('https://api.example.com/data')\n  .tap(data =&gt; console.log(data))\n  .catchError(error =&gt; console.error(error));\n</code></pre> </p>"},{"location":"api/http/#httpposturl-data-config-httpstream","title":"http.post(url, [data], [config]) \u21d2 <code>HTTPStream</code>","text":"<p>Sends a POST request.</p> <p>Kind: static method of <code>http</code> Returns: <code>HTTPStream</code> - An HTTPStream that resolves to the response data.  </p> Param Type Default Description url <code>string</code> The URL to send the POST request to. [data] <code>Object</code> <code>{}</code> The data to send in the body of the POST request. [config] <code>Object</code> <code>{}</code> Optional configuration object. <p>Example <pre><code>http.post('https://jsonplaceholder.typicode.com/posts', { title: 'foo', body: 'bar', userId: 1 })\n  .tap(data =&gt; console.log(data))\n  .catchError(error =&gt; console.error(error));\n</code></pre> </p>"},{"location":"api/http/#httpputurl-data-config-httpstream","title":"http.put(url, [data], [config]) \u21d2 <code>HTTPStream</code>","text":"<p>Sends a PUT request.</p> <p>Kind: static method of <code>http</code> Returns: <code>HTTPStream</code> - An HTTPStream that resolves to the response data.  </p> Param Type Default Description url <code>string</code> The URL to send the PUT request to. [data] <code>Object</code> <code>{}</code> The data to send in the body of the PUT request. [config] <code>Object</code> <code>{}</code> Optional configuration object. <p>Example <pre><code>http.put('https://jsonplaceholder.typicode.com/posts/1', { id: 1, title: 'foo', body: 'bar', userId: 1 })\n  .tap(data =&gt; console.log(data))\n  .catchError(error =&gt; console.error(error));\n</code></pre> </p>"},{"location":"api/http/#httppatchurl-data-config-httpstream","title":"http.patch(url, [data], [config]) \u21d2 <code>HTTPStream</code>","text":"<p>Sends a PATCH request.</p> <p>Kind: static method of <code>http</code> Returns: <code>HTTPStream</code> - An HTTPStream that resolves to the response data.  </p> Param Type Default Description url <code>string</code> The URL to send the PATCH request to. [data] <code>Object</code> <code>{}</code> The data to send in the body of the PATCH request. [config] <code>Object</code> <code>{}</code> Optional configuration object. <p>Example <pre><code>http.patch('https://jsonplaceholder.typicode.com/posts/1', { title: 'foo' })\n  .tap(data =&gt; console.log(data))\n  .catchError(error =&gt; console.error(error));\n</code></pre> </p>"},{"location":"api/http/#httpdeleteurl-config-httpstream","title":"http.delete(url, [config]) \u21d2 <code>HTTPStream</code>","text":"<p>Sends a DELETE request.</p> <p>Kind: static method of <code>http</code> Returns: <code>HTTPStream</code> - An HTTPStream that resolves to the response data.  </p> Param Type Default Description url <code>string</code> The URL to send the DELETE request to. [config] <code>Object</code> <code>{}</code> Optional configuration object. <p>Example <pre><code>http.delete('https://jsonplaceholder.typicode.com/posts/1')\n  .tap(data =&gt; console.log(data))\n  .catchError(error =&gt; console.error(error));\n</code></pre> </p>"},{"location":"api/http/#httpsseurl-config-httpstream","title":"http.sse(url, [config]) \u21d2 <code>HTTPStream</code>","text":"<p>Establishes a Server-Sent Events connection.</p> <p>Kind: static method of <code>http</code> Returns: <code>HTTPStream</code> - An HTTPStream with methods to register event handlers, handle errors, and close the connection.  </p> Param Type Default Description url <code>string</code> The URL to establish a Server-Sent Events connection. [config] <code>Object</code> <code>{}</code> Optional configuration object. <p>Example <pre><code>const stream = http.sse('https://api.example.com/events');\nstream.on('message', event =&gt; console.log(event.data));\nstream.catchError(error =&gt; console.error(error));\n</code></pre></p>"},{"location":"api/observable/","title":"Observable","text":""},{"location":"api/observable/#classes","title":"Classes","text":"Subscriber Observable"},{"location":"api/observable/#typedefs","title":"Typedefs","text":"Observer : <code>Object</code> <p>The observer object or function.</p> <p></p>"},{"location":"api/observable/#subscriber","title":"Subscriber","text":"<p>Kind: global class  </p> <ul> <li>Subscriber<ul> <li>new Subscriber(observer)</li> <li>.next(result)</li> <li>.complete()</li> <li>.error(error)</li> <li>.addTeardown(teardown)</li> <li>.unsubscribe()</li> </ul> </li> </ul> <p></p>"},{"location":"api/observable/#new-subscriberobserver","title":"new Subscriber(observer)","text":"<p>Class representing a Subscriber.</p> Param Type Description observer <code>Observer</code> | <code>function</code> The observer object or function. <p></p>"},{"location":"api/observable/#subscribernextresult","title":"subscriber.next(result)","text":"<p>Notifies the observer of a new value.</p> <p>Kind: instance method of <code>Subscriber</code> </p> Param Type Description result <code>any</code> The result to pass to the observer's next method. <p>Example <pre><code>subscriber.next('Hello, world!');\n</code></pre> </p>"},{"location":"api/observable/#subscribercomplete","title":"subscriber.complete()","text":"<p>Notifies the observer that the observable has completed and no more data will be emitted.</p> <p>Kind: instance method of <code>Subscriber</code> Example <pre><code>subscriber.complete();\n</code></pre> </p>"},{"location":"api/observable/#subscribererrorerror","title":"subscriber.error(error)","text":"<p>Notifies the observer that an error has occurred.</p> <p>Kind: instance method of <code>Subscriber</code> </p> Param Type Description error <code>Error</code> The error to pass to the observer's error method. <p>Example <pre><code>subscriber.error(new Error('Something went wrong'));\n</code></pre> </p>"},{"location":"api/observable/#subscriberaddteardownteardown","title":"subscriber.addTeardown(teardown)","text":"<p>Adds a teardown function to the teardowns array.</p> <p>Kind: instance method of <code>Subscriber</code> </p> Param Type Description teardown <code>function</code> The teardown function to add to the teardowns array. <p></p>"},{"location":"api/observable/#subscriberunsubscribe","title":"subscriber.unsubscribe()","text":"<p>Unsubscribes from the observable, preventing any further notifications to the observer and triggering any teardown logic.</p> <p>Kind: instance method of <code>Subscriber</code> Example <pre><code>subscriber.unsubscribe();\n</code></pre> </p>"},{"location":"api/observable/#observable","title":"Observable","text":"<p>Kind: global class  </p> <ul> <li>Observable<ul> <li>new Observable(subscribeCallback)</li> <li>.subscribe(observerOrNext, error, complete) \u21d2 <code>Object</code></li> <li>.next(value)</li> <li>.error(error)</li> <li>.complete()</li> <li>.onValue(callbackFn) \u21d2 <code>Object</code></li> <li>.onError(callbackFn) \u21d2 <code>Object</code></li> <li>.onEnd(callbackFn) \u21d2 <code>Object</code></li> </ul> </li> </ul> <p></p>"},{"location":"api/observable/#new-observablesubscribecallback","title":"new Observable(subscribeCallback)","text":"<p>Class representing an Observable.</p> Param Type Description subscribeCallback <code>function</code> The callback function to call when a new observer subscribes. <p></p>"},{"location":"api/observable/#observablesubscribeobserverornext-error-complete-object","title":"observable.subscribe(observerOrNext, error, complete) \u21d2 <code>Object</code>","text":"<p>Subscribes an observer to the observable.</p> <p>Kind: instance method of <code>Observable</code> Returns: <code>Object</code> - An object containing an unsubscribe method to stop receiving updates.  </p> Param Type Description observerOrNext <code>Observer</code> | <code>function</code> The observer to subscribe or the next function. Default is an empty function. error <code>function</code> The error function. Default is an empty function. complete <code>function</code> The complete function. Default is an empty function. <p>Example <pre><code>const observable = new Observable();\nconst subscription = observable.subscribe({\n  next: value =&gt; console.log(value),\n  error: err =&gt; console.error(err),\n  complete: () =&gt; console.log('Completed'),\n});\n</code></pre> </p>"},{"location":"api/observable/#observablenextvalue","title":"observable.next(value)","text":"<p>Passes a value to the observer's next method.</p> <p>Kind: instance method of <code>Observable</code> </p> Param Type Description value <code>*</code> The value to be passed to the observer's next method. <p>Example <pre><code>const observable = new Observable();\nobservable.next('Hello, world!');\n</code></pre> </p>"},{"location":"api/observable/#observableerrorerror","title":"observable.error(error)","text":"<p>Passes an error to the observer's error method.</p> <p>Kind: instance method of <code>Observable</code> </p> Param Type Description error <code>*</code> The error to be passed to the observer's error method. <p>Example <pre><code>const observable = new Observable();\nobservable.error(new Error('Something went wrong'));\n</code></pre> </p>"},{"location":"api/observable/#observablecomplete","title":"observable.complete()","text":"<p>Calls the complete method on all observers.</p> <p>Kind: instance method of <code>Observable</code> Example <pre><code>const observable = new Observable();\nobservable.complete();\n</code></pre> </p>"},{"location":"api/observable/#observableonvaluecallbackfn-object","title":"observable.onValue(callbackFn) \u21d2 <code>Object</code>","text":"<p>Subscribes an observer with a next function to the observable.</p> <p>Kind: instance method of <code>Observable</code> Returns: <code>Object</code> - An object containing an unsubscribe method to stop receiving updates.  </p> Param Type Description callbackFn <code>function</code> The callback function to call when a new value is emitted. <p>Example <pre><code>const observable = new Observable();\nconst subscription = observable.onValue(value =&gt; console.log(value));\n</code></pre> </p>"},{"location":"api/observable/#observableonerrorcallbackfn-object","title":"observable.onError(callbackFn) \u21d2 <code>Object</code>","text":"<p>Subscribes an observer with an error function to the observable.</p> <p>Kind: instance method of <code>Observable</code> Returns: <code>Object</code> - An object containing an unsubscribe method to stop receiving updates.  </p> Param Type Description callbackFn <code>function</code> The callback function to call when an error is emitted. <p>Example <pre><code>const observable = new Observable();\nconst subscription = observable.onError(err =&gt; console.error(err));\n</code></pre> </p>"},{"location":"api/observable/#observableonendcallbackfn-object","title":"observable.onEnd(callbackFn) \u21d2 <code>Object</code>","text":"<p>Subscribes an observer with a complete function to the observable.</p> <p>Kind: instance method of <code>Observable</code> Returns: <code>Object</code> - An object containing an unsubscribe method to stop receiving updates.  </p> Param Type Description callbackFn <code>function</code> The callback function to call when the observable completes. <p>Example <pre><code>const observable = new Observable();\nconst subscription = observable.onEnd(() =&gt; console.log('Completed'));\n</code></pre> </p>"},{"location":"api/observable/#observer-object","title":"Observer : <code>Object</code>","text":"<p>The observer object or function.</p> <p>Kind: global typedef Properties</p> Name Type Description next <code>function</code> Function to handle new values. error <code>function</code> Function to handle errors. complete <code>function</code> Function to handle completion."},{"location":"api/observable_state/","title":"Observable state","text":""},{"location":"api/observable_state/#classes","title":"Classes","text":"ObservableState \u21d0 <code>Observable</code> ComputedState \u21d0 <code>ObservableState</code>"},{"location":"api/observable_state/#functions","title":"Functions","text":"computed(computeFn) \u21d2 <code>ComputedState</code> effect(effectFn) \u21d2 <code>function</code> <p>This function sets up an effect that is run when the observable changes</p> <p></p>"},{"location":"api/observable_state/#observablestate-observable","title":"ObservableState \u21d0 <code>Observable</code>","text":"<p>Kind: global class Extends: <code>Observable</code> </p> <ul> <li>ObservableState \u21d0 <code>Observable</code><ul> <li>new ObservableState(initialValue, subscriber, options)</li> <li>.value() \u21d2 <code>any</code></li> <li>.value(newValue)</li> <li>.assign(obj)</li> <li>.set(key, value)</li> <li>.delete(key)</li> <li>.clear()</li> <li>.push(...elements)</li> <li>.pop()</li> <li>.shift()</li> <li>.splice(start, deleteCount, ...items)</li> <li>.unshift(...elements)</li> <li>.reverse()</li> <li>.sort([compareFunction])</li> <li>.fill(value, [start], [end])</li> <li>.copyWithin(target, start, [end])</li> <li>.update(updater)</li> <li>.toStream() \u21d2 <code>ObservableStream</code></li> <li>.complete()</li> </ul> </li> </ul> <p></p>"},{"location":"api/observable_state/#new-observablestateinitialvalue-subscriber-options","title":"new ObservableState(initialValue, subscriber, options)","text":"<p>This class extends the Observable class and adds methods for updating the value of the observable.</p> Param Type Default Description initialValue <code>any</code> <code></code> The initial value of the observable subscriber <code>Subscriber</code> <code></code> The subscriber to the observable options <code>Object</code> Additional options for the observable options.last <code>boolean</code> Whether the subscriber is the last observer <p>Example <pre><code>import { ObservableState } from 'cami-js';\nconst observable = new ObservableState(10);\nconsole.log(observable.value); // 10\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatevalue-any","title":"observableState.value() \u21d2 <code>any</code>","text":"<p>Kind: instance method of <code>ObservableState</code> Returns: <code>any</code> - The current value of the observable Example <pre><code>const value = observable.value;\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatevaluenewvalue","title":"observableState.value(newValue)","text":"<p>This method sets a new value for the observable by calling the update method with the new value.</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description newValue <code>any</code> The new value to set for the observable <p>Example <pre><code>observable.value = 20;\n</code></pre> </p>"},{"location":"api/observable_state/#observablestateassignobj","title":"observableState.assign(obj)","text":"<p>Merges properties from the provided object into the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description obj <code>Object</code> The object whose properties to merge <p>Example <pre><code>observable.assign({ key: 'value' });\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatesetkey-value","title":"observableState.set(key, value)","text":"<p>Sets a new key/value pair in the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description key <code>any</code> The key to set value <code>any</code> The value to set <p>Example <pre><code>observable.set('key', 'value');\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatedeletekey","title":"observableState.delete(key)","text":"<p>Removes a key/value pair from the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description key <code>any</code> The key to remove <p>Example <pre><code>observable.delete('key');\n</code></pre> </p>"},{"location":"api/observable_state/#observablestateclear","title":"observableState.clear()","text":"<p>Removes all key/value pairs from the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> Example <pre><code>observable.clear();\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatepushelements","title":"observableState.push(...elements)","text":"<p>Adds one or more elements to the end of the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description ...elements <code>any</code> The elements to add <p>Example <pre><code>observable.push(1, 2, 3);\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatepop","title":"observableState.pop()","text":"<p>Removes the last element from the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> Example <pre><code>observable.pop();\n</code></pre> </p>"},{"location":"api/observable_state/#observablestateshift","title":"observableState.shift()","text":"<p>Removes the first element from the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> Example <pre><code>observable.shift();\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatesplicestart-deletecount-items","title":"observableState.splice(start, deleteCount, ...items)","text":"<p>Changes the contents of the observable's value by removing, replacing, or adding elements</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description start <code>number</code> The index at which to start changing the array deleteCount <code>number</code> The number of elements to remove ...items <code>any</code> The elements to add to the array <p>Example <pre><code>observable.splice(0, 1, 'newElement');\n</code></pre> </p>"},{"location":"api/observable_state/#observablestateunshiftelements","title":"observableState.unshift(...elements)","text":"<p>Adds one or more elements to the beginning of the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description ...elements <code>any</code> The elements to add <p>Example <pre><code>observable.unshift('newElement');\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatereverse","title":"observableState.reverse()","text":"<p>Reverses the order of the elements in the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> Example <pre><code>observable.reverse();\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatesortcomparefunction","title":"observableState.sort([compareFunction])","text":"<p>Sorts the elements in the observable's value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description [compareFunction] <code>function</code> The function used to determine the order of the elements <p>Example <pre><code>observable.sort((a, b) =&gt; a - b);\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatefillvalue-start-end","title":"observableState.fill(value, [start], [end])","text":"<p>Changes all elements in the observable's value to a static value</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Default Description value <code>any</code> The value to fill the array with [start] <code>number</code> <code>0</code> The index to start filling at [end] <code>number</code> <code>this._value.length</code> The index to stop filling at <p>Example <pre><code>observable.fill('newElement', 0, 2);\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatecopywithintarget-start-end","title":"observableState.copyWithin(target, start, [end])","text":"<p>Shallow copies part of the observable's value to another location in the same array</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Default Description target <code>number</code> The index to copy the elements to start <code>number</code> The start index to begin copying elements from [end] <code>number</code> <code>this._value.length</code> The end index to stop copying elements from <p>Example <pre><code>observable.copyWithin(0, 1, 2);\n</code></pre> </p>"},{"location":"api/observable_state/#observablestateupdateupdater","title":"observableState.update(updater)","text":"<p>This method adds the updater function to the pending updates queue. It uses a synchronous approach to schedule the updates, ensuring the whole state is consistent at each tick. This is done to batch multiple updates together and avoid unnecessary re-renders.</p> <p>Kind: instance method of <code>ObservableState</code> </p> Param Type Description updater <code>function</code> The function to update the value <p>Example <pre><code>observable.update(value =&gt; value + 1);\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatetostream-observablestream","title":"observableState.toStream() \u21d2 <code>ObservableStream</code>","text":"<p>Converts the ObservableState to an ObservableStream.</p> <p>Kind: instance method of <code>ObservableState</code> Returns: <code>ObservableStream</code> - The ObservableStream that emits the same values as the ObservableState. Example <pre><code>const stream = observable.toStream();\n</code></pre> </p>"},{"location":"api/observable_state/#observablestatecomplete","title":"observableState.complete()","text":"<p>Calls the complete method of all observers.</p> <p>Kind: instance method of <code>ObservableState</code> Example <pre><code>observable.complete();\n</code></pre> </p>"},{"location":"api/observable_state/#computedstate-observablestate","title":"ComputedState \u21d0 <code>ObservableState</code>","text":"<p>Kind: global class Extends: <code>ObservableState</code> </p> <ul> <li>ComputedState \u21d0 <code>ObservableState</code><ul> <li>new ComputedState(computeFn)</li> <li>.value() \u21d2 <code>any</code></li> <li>.dispose()</li> <li>.assign(obj)</li> <li>.set(key, value)</li> <li>.delete(key)</li> <li>.clear()</li> <li>.push(...elements)</li> <li>.pop()</li> <li>.shift()</li> <li>.splice(start, deleteCount, ...items)</li> <li>.unshift(...elements)</li> <li>.reverse()</li> <li>.sort([compareFunction])</li> <li>.fill(value, [start], [end])</li> <li>.copyWithin(target, start, [end])</li> <li>.update(updater)</li> <li>.toStream() \u21d2 <code>ObservableStream</code></li> <li>.complete()</li> </ul> </li> </ul> <p></p>"},{"location":"api/observable_state/#new-computedstatecomputefn","title":"new ComputedState(computeFn)","text":"<p>ComputedState class that extends ObservableState and holds additional methods for computed observables</p> Param Type Description computeFn <code>function</code> The function to compute the value of the observable <p>Example <pre><code>const computedState = new ComputedState(() =&gt; observable.value * 2);\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatevalue-any","title":"computedState.value() \u21d2 <code>any</code>","text":"<p>Kind: instance method of <code>ComputedState</code> Overrides: <code>value</code> Returns: <code>any</code> - The current value of the observable Example <pre><code>const value = computedState.value;\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatedispose","title":"computedState.dispose()","text":"<p>Unsubscribes from all dependencies</p> <p>Kind: instance method of <code>ComputedState</code> Example <pre><code>// Assuming `obs` is an instance of ObservableState\nobs.dispose(); // This will unsubscribe obs from all its dependencies\n</code></pre> </p>"},{"location":"api/observable_state/#computedstateassignobj","title":"computedState.assign(obj)","text":"<p>Merges properties from the provided object into the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>assign</code> </p> Param Type Description obj <code>Object</code> The object whose properties to merge <p>Example <pre><code>observable.assign({ key: 'value' });\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatesetkey-value","title":"computedState.set(key, value)","text":"<p>Sets a new key/value pair in the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>set</code> </p> Param Type Description key <code>any</code> The key to set value <code>any</code> The value to set <p>Example <pre><code>observable.set('key', 'value');\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatedeletekey","title":"computedState.delete(key)","text":"<p>Removes a key/value pair from the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>delete</code> </p> Param Type Description key <code>any</code> The key to remove <p>Example <pre><code>observable.delete('key');\n</code></pre> </p>"},{"location":"api/observable_state/#computedstateclear","title":"computedState.clear()","text":"<p>Removes all key/value pairs from the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>clear</code> Example <pre><code>observable.clear();\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatepushelements","title":"computedState.push(...elements)","text":"<p>Adds one or more elements to the end of the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>push</code> </p> Param Type Description ...elements <code>any</code> The elements to add <p>Example <pre><code>observable.push(1, 2, 3);\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatepop","title":"computedState.pop()","text":"<p>Removes the last element from the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>pop</code> Example <pre><code>observable.pop();\n</code></pre> </p>"},{"location":"api/observable_state/#computedstateshift","title":"computedState.shift()","text":"<p>Removes the first element from the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>shift</code> Example <pre><code>observable.shift();\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatesplicestart-deletecount-items","title":"computedState.splice(start, deleteCount, ...items)","text":"<p>Changes the contents of the observable's value by removing, replacing, or adding elements</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>splice</code> </p> Param Type Description start <code>number</code> The index at which to start changing the array deleteCount <code>number</code> The number of elements to remove ...items <code>any</code> The elements to add to the array <p>Example <pre><code>observable.splice(0, 1, 'newElement');\n</code></pre> </p>"},{"location":"api/observable_state/#computedstateunshiftelements","title":"computedState.unshift(...elements)","text":"<p>Adds one or more elements to the beginning of the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>unshift</code> </p> Param Type Description ...elements <code>any</code> The elements to add <p>Example <pre><code>observable.unshift('newElement');\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatereverse","title":"computedState.reverse()","text":"<p>Reverses the order of the elements in the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>reverse</code> Example <pre><code>observable.reverse();\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatesortcomparefunction","title":"computedState.sort([compareFunction])","text":"<p>Sorts the elements in the observable's value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>sort</code> </p> Param Type Description [compareFunction] <code>function</code> The function used to determine the order of the elements <p>Example <pre><code>observable.sort((a, b) =&gt; a - b);\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatefillvalue-start-end","title":"computedState.fill(value, [start], [end])","text":"<p>Changes all elements in the observable's value to a static value</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>fill</code> </p> Param Type Default Description value <code>any</code> The value to fill the array with [start] <code>number</code> <code>0</code> The index to start filling at [end] <code>number</code> <code>this._value.length</code> The index to stop filling at <p>Example <pre><code>observable.fill('newElement', 0, 2);\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatecopywithintarget-start-end","title":"computedState.copyWithin(target, start, [end])","text":"<p>Shallow copies part of the observable's value to another location in the same array</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>copyWithin</code> </p> Param Type Default Description target <code>number</code> The index to copy the elements to start <code>number</code> The start index to begin copying elements from [end] <code>number</code> <code>this._value.length</code> The end index to stop copying elements from <p>Example <pre><code>observable.copyWithin(0, 1, 2);\n</code></pre> </p>"},{"location":"api/observable_state/#computedstateupdateupdater","title":"computedState.update(updater)","text":"<p>This method adds the updater function to the pending updates queue. It uses a synchronous approach to schedule the updates, ensuring the whole state is consistent at each tick. This is done to batch multiple updates together and avoid unnecessary re-renders.</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>update</code> </p> Param Type Description updater <code>function</code> The function to update the value <p>Example <pre><code>observable.update(value =&gt; value + 1);\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatetostream-observablestream","title":"computedState.toStream() \u21d2 <code>ObservableStream</code>","text":"<p>Converts the ObservableState to an ObservableStream.</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>toStream</code> Returns: <code>ObservableStream</code> - The ObservableStream that emits the same values as the ObservableState. Example <pre><code>const stream = observable.toStream();\n</code></pre> </p>"},{"location":"api/observable_state/#computedstatecomplete","title":"computedState.complete()","text":"<p>Calls the complete method of all observers.</p> <p>Kind: instance method of <code>ComputedState</code> Overrides: <code>complete</code> Example <pre><code>observable.complete();\n</code></pre> </p>"},{"location":"api/observable_state/#computedcomputefn-computedstate","title":"computed(computeFn) \u21d2 <code>ComputedState</code>","text":"<p>Kind: global function Returns: <code>ComputedState</code> - A new instance of ComputedState  </p> Param Type Description computeFn <code>function</code> The function to compute the value of the observable <p>Example <pre><code>// Assuming `computeFn` is a function that computes the value of the observable\nconst computedValue = computed(computeFn);\n</code></pre> </p>"},{"location":"api/observable_state/#effecteffectfn-function","title":"effect(effectFn) \u21d2 <code>function</code>","text":"<p>This function sets up an effect that is run when the observable changes</p> <p>Kind: global function Returns: <code>function</code> - A function that when called, unsubscribes from all dependencies and runs cleanup function  </p> Param Type Description effectFn <code>function</code> The function to call for the effect <p>Example <pre><code>// Assuming `effectFn` is a function that is called when the observable changes\nconst effectFunction = effect(effectFn);\n</code></pre></p> <ul> <li>effect(effectFn) \u21d2 <code>function</code><ul> <li>~tracker</li> <li>~_runEffect()</li> <li>~dispose() \u21d2 <code>void</code></li> </ul> </li> </ul> <p></p>"},{"location":"api/observable_state/#effecttracker","title":"effect~tracker","text":"<p>The tracker object is used to keep track of dependencies for the effect function. It provides a method to add a dependency (an observable) to the dependencies set. If the observable is not already a dependency, it is added to the set and a subscription is created to run the effect function whenever the observable's value changes. This mechanism allows the effect function to respond to state changes in its dependencies.</p> <p>Kind: inner constant of <code>effect</code> </p>"},{"location":"api/observable_state/#effect_runeffect","title":"effect~_runEffect()","text":"<p>The _runEffect function is responsible for running the effect function and managing its dependencies. Before the effect function is run, any cleanup from the previous run is performed and the current tracker is set to this tracker. This allows the effect function to add dependencies via the tracker while it is running. After the effect function has run, the current tracker is set back to null to prevent further dependencies from being added outside of the effect function. The effect function is expected to return a cleanup function, which is saved for the next run. The cleanup function, initially empty, is replaced by the one returned from effectFn (run by the observable) before each new run and on effect disposal.</p> <p>Kind: inner method of <code>effect</code> </p>"},{"location":"api/observable_state/#effectdispose-void","title":"effect~dispose() \u21d2 <code>void</code>","text":"<p>Unsubscribes from all dependencies and runs cleanup function</p> <p>Kind: inner method of <code>effect</code> Example <pre><code>// Assuming `dispose` is the function returned by `effect`\ndispose(); // This will unsubscribe from all dependencies and run cleanup function\n</code></pre></p>"},{"location":"api/observable_store/","title":"Observable store","text":""},{"location":"api/observable_store/#classes","title":"Classes","text":"ObservableStore \u21d0 <code>Observable</code>"},{"location":"api/observable_store/#functions","title":"Functions","text":"store(initialState, [options]) \u21d2 <code>ObservableStore</code> <p>This function creates a new instance of ObservableStore with the provided initial state and enhances it with localStorage support if enabled. The store's state will be automatically persisted to and loaded from localStorage, using the provided name as the key. The <code>localStorage</code> option enables this behavior and can be toggled off if persistence is not needed.</p> <p></p>"},{"location":"api/observable_store/#observablestore-observable","title":"ObservableStore \u21d0 <code>Observable</code>","text":"<p>Kind: global class Extends: <code>Observable</code> </p> <ul> <li>ObservableStore \u21d0 <code>Observable</code><ul> <li>new ObservableStore()</li> <li>.use(middleware)</li> <li>.register(action, reducer)</li> <li>.dispatch(action, payload)</li> </ul> </li> </ul> <p></p>"},{"location":"api/observable_store/#new-observablestore","title":"new ObservableStore()","text":"<p>This class is used to create a store that can be observed for changes. Adding the actions on the store is recommended.</p> <p>Example <pre><code>const CartStore = cami.store({\n  cartItems: [],\n  add: (store, product) =&gt; {\n    const cartItem = { ...product, cartItemId: Date.now() };\n    store.cartItems.push(cartItem);\n  },\n  remove: (store, product) =&gt; {\n    store.cartItems = store.cartItems.filter(item =&gt; item.cartItemId !== product.cartItemId);\n  }\n});\n</code></pre> </p>"},{"location":"api/observable_store/#observablestoreusemiddleware","title":"ObservableStore.use(middleware)","text":"<p>This method registers a middleware function to be used with the store. Useful if you like redux-style middleware.</p> <p>Kind: static method of <code>ObservableStore</code> </p> Param Type Description middleware <code>function</code> The middleware function to use <p>Example <pre><code>const loggerMiddleware = (context) =&gt; {\n  console.log(`Action ${context.action} was dispatched with payload:`, context.payload);\n};\nCartStore.use(loggerMiddleware);\n</code></pre> </p>"},{"location":"api/observable_store/#observablestoreregisteraction-reducer","title":"ObservableStore.register(action, reducer)","text":"<p>This method registers a reducer function for a given action type. Useful if you like redux-style reducers.</p> <p>Kind: static method of <code>ObservableStore</code> Throws:</p> <ul> <li><code>Error</code> - Throws an error if the action type is already registered</li> </ul> Param Type Description action <code>string</code> The action type reducer <code>function</code> The reducer function for the action <p>Example <pre><code>CartStore.register('add', (store, product) =&gt; {\n  const cartItem = { ...product, cartItemId: Date.now() };\n  store.cartItems.push(cartItem);\n});\n</code></pre> </p>"},{"location":"api/observable_store/#observablestoredispatchaction-payload","title":"ObservableStore.dispatch(action, payload)","text":"<p>This method dispatches an action to the store. Useful if you like redux-style actions / flux.</p> <p>Kind: static method of <code>ObservableStore</code> Throws:</p> <ul> <li><code>Error</code> - Throws an error if the action type is not a string</li> </ul> Param Type Description action <code>string</code> | <code>function</code> The action type or a function payload <code>Object</code> The payload for the action <p>Example <pre><code>CartStore.dispatch('add', product);\n</code></pre> </p>"},{"location":"api/observable_store/#storeinitialstate-options-observablestore","title":"store(initialState, [options]) \u21d2 <code>ObservableStore</code>","text":"<p>This function creates a new instance of ObservableStore with the provided initial state and enhances it with localStorage support if enabled. The store's state will be automatically persisted to and loaded from localStorage, using the provided name as the key. The <code>localStorage</code> option enables this behavior and can be toggled off if persistence is not needed.</p> <p>Kind: global function Returns: <code>ObservableStore</code> - A new instance of ObservableStore with the provided initial state, enhanced with localStorage if enabled.  </p> Param Type Default Description initialState <code>Object</code> The initial state of the store. [options] <code>Object</code> Configuration options for the store. [options.localStorage] <code>boolean</code> <code>true</code> Whether to use localStorage for state persistence. [options.name] <code>string</code> <code>\"'cami-store'\"</code> The name of the store to use as the key in localStorage. [options.expiry] <code>number</code> <code>86400000</code> The time in milliseconds until the stored state expires (default is 24 hours). <p>Example <pre><code>// Create a store with default localStorage support\nconst CartStore = store({ cartItems: [] });\n\n// Create a store without localStorage support\nconst NonPersistentStore = store({ items: [] }, { localStorage: false });\n</code></pre></p>"},{"location":"api/observable_stream/","title":"Observable stream","text":""},{"location":"api/observable_stream/#observablestream-observable","title":"ObservableStream \u21d0 <code>Observable</code>","text":"<p>Kind: global class Extends: <code>Observable</code> </p> <ul> <li>ObservableStream \u21d0 <code>Observable</code><ul> <li>new ObservableStream()</li> <li>instance<ul> <li>.map(transformFn) \u21d2 <code>ObservableStream</code></li> <li>.filter(predicateFn) \u21d2 <code>ObservableStream</code></li> <li>.reduce(reducerFn, initialValue) \u21d2 <code>Promise</code></li> <li>.takeUntil(notifier) \u21d2 <code>ObservableStream</code></li> <li>.take(n) \u21d2 <code>ObservableStream</code></li> <li>.drop(n) \u21d2 <code>ObservableStream</code></li> <li>.flatMap(transformFn) \u21d2 <code>ObservableStream</code></li> <li>.switchMap(transformFn) \u21d2 <code>ObservableStream</code></li> <li>.toArray() \u21d2 <code>Promise</code></li> <li>.forEach(callback) \u21d2 <code>Promise</code></li> <li>.every(predicate) \u21d2 <code>Promise</code></li> <li>.find(predicate) \u21d2 <code>Promise</code></li> <li>.some(predicate) \u21d2 <code>Promise</code></li> <li>.finally(callback) \u21d2 <code>ObservableStream</code></li> <li>.toState() \u21d2 <code>ObservableState</code></li> <li>.push(value)</li> <li>.plug(stream)</li> <li>.end()</li> <li>.catchError(fn) \u21d2 <code>ObservableStream</code></li> <li>.debounce(delay) \u21d2 <code>ObservableStream</code></li> <li>.tap(sideEffectFn) \u21d2 <code>ObservableStream</code></li> <li>.throttle(duration) \u21d2 <code>ObservableStream</code></li> <li>.distinctUntilChanged() \u21d2 <code>ObservableStream</code></li> <li>.concatMap(transformFn) \u21d2 <code>ObservableStream</code></li> <li>.combineLatest(...observables) \u21d2 <code>ObservableStream</code></li> <li>.startWith(...initialValues) \u21d2 <code>ObservableStream</code></li> </ul> </li> <li>static<ul> <li>.from(value) \u21d2 <code>ObservableStream</code></li> </ul> </li> </ul> </li> </ul> <p></p>"},{"location":"api/observable_stream/#new-observablestream","title":"new ObservableStream()","text":"<p>ObservableStream class that extends Observable and provides additional methods for data transformation</p> <p></p>"},{"location":"api/observable_stream/#observablestreammaptransformfn-observablestream","title":"observableStream.map(transformFn) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream instance with transformed data  </p> Param Type Description transformFn <code>function</code> The function to transform the data <p>Example <pre><code>// Example 1: Transforming an API data stream\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst transformedStream = observableStream.map(data =&gt; data.map(item =&gt; item * 2));\n\n// Example 2: Transforming a user event stream\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\nconst transformedStream = observableStream.map(event =&gt; ({ x: event.clientX, y: event.clientY }));\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamfilterpredicatefn-observablestream","title":"observableStream.filter(predicateFn) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream instance with filtered data  </p> Param Type Description predicateFn <code>function</code> The function to filter the data <p>Example <pre><code>// Example 1: Filtering an API data stream\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst filteredStream = observableStream.filter(data =&gt; data.someProperty === 'someValue');\n\n// Example 2: Filtering a user event stream\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\nconst filteredStream = observableStream.filter(event =&gt; event.target.id === 'someId');\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamreducereducerfn-initialvalue-promise","title":"observableStream.reduce(reducerFn, initialValue) \u21d2 <code>Promise</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>Promise</code> - A promise that resolves with the reduced value  </p> Param Type Description reducerFn <code>function</code> The function to reduce the data initialValue <code>any</code> The initial value for the reducer <p>Example <pre><code>// Example 1: Reducing an API data stream\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst reducedValuePromise = observableStream.reduce((acc, data) =&gt; acc + data.someProperty, 0);\n\n// Example 2: Reducing a user event stream\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\nconst reducedValuePromise = observableStream.reduce((acc, event) =&gt; acc + 1, 0);\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamtakeuntilnotifier-observablestream","title":"observableStream.takeUntil(notifier) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that completes when the notifier emits  </p> Param Type Description notifier <code>Observable</code> The Observable that will complete this Observable <p>Example <pre><code>// Example 1: Completing an API data stream when another stream emits\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst notifierStream = new ObservableStream(subscriber =&gt; {\n  setTimeout(() =&gt; subscriber.next(), 5000);\n});\nconst completedStream = observableStream.takeUntil(notifierStream);\n\n// Example 2: Completing a user event stream when another stream emits\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\nconst notifierStream = new ObservableStream(subscriber =&gt; {\n  setTimeout(() =&gt; subscriber.next(), 5000);\n});\nconst completedStream = observableStream.takeUntil(notifierStream);\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamtaken-observablestream","title":"observableStream.take(n) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that completes after emitting n values  </p> Param Type Description n <code>number</code> The number of values to take <p>Example <pre><code>// Example 1: Taking a certain number of values from an API data stream\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst takenStream = observableStream.take(5);\n\n// Example 2: Taking a certain number of values from a user event stream\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\nconst takenStream = observableStream.take(5);\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamdropn-observablestream","title":"observableStream.drop(n) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that starts emitting after n values have been emitted  </p> Param Type Description n <code>number</code> The number of values to drop <p>Example <pre><code>// Example 1: Dropping a certain number of values from an API data stream\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst droppedStream = observableStream.drop(5);\n\n// Example 2: Dropping a certain number of values from a user event stream\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\nconst droppedStream = observableStream.drop(5);\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamflatmaptransformfn-observablestream","title":"observableStream.flatMap(transformFn) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits the values from the inner Observables  </p> Param Type Description transformFn <code>function</code> The function to transform the data into Observables <p>Example <pre><code>// Example 1: Transforming an API data stream into inner Observables\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst flatMappedStream = observableStream.flatMap(data =&gt; ObservableStream.from(fetch(`https://api.example.com/data/${data.id}`).then(response =&gt; response.json())));\n\n// Example 2: Transforming a user event stream into inner Observables\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst positionStream = clickStream.flatMap(event =&gt; ObservableStream.from({ x: event.clientX, y: event.clientY }));\n\n// Example 3: Transforming a stream of search terms into a stream of search results\nconst searchTerms = new ObservableStream(subscriber =&gt; {\n  const input = document.querySelector('#search-input');\n  input.addEventListener('input', event =&gt; subscriber.next(event.target.value));\n});\nconst searchResults = searchTerms.debounce(300).flatMap(term =&gt; ObservableStream.from(fetch(`https://api.example.com/search?q=${term}`).then(response =&gt; response.json())));\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamswitchmaptransformfn-observablestream","title":"observableStream.switchMap(transformFn) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits the values from the inner Observables  </p> Param Type Description transformFn <code>function</code> The function to transform the data into Observables <p>Example <pre><code>// Example 1: Transforming click events into Observables\nconst clickStream = new ObservableStream();\ndocument.addEventListener('click', (event) =&gt; clickStream.push(event));\nconst positionStream = clickStream.switchMap((event) =&gt; {\n  return new ObservableStream((subscriber) =&gt; {\n    subscriber.push({ x: event.clientX, y: event.clientY });\n    subscriber.complete();\n  });\n});\npositionStream.subscribe({\n  next: (position) =&gt; console.log(`Clicked at position: ${position.x}, ${position.y}`),\n  error: (err) =&gt; console.error(err),\n});\n\n// Example 2: Transforming API responses into Observables\nconst apiStream = new ObservableStream();\nfetch('https://api.example.com/data')\n  .then((response) =&gt; response.json())\n  .then((data) =&gt; apiStream.push(data))\n  .catch((error) =&gt; apiStream.error(error));\nconst transformedStream = apiStream.switchMap((data) =&gt; {\n  return new ObservableStream((subscriber) =&gt; {\n    subscriber.push(transformData(data));\n    subscriber.complete();\n  });\n});\ntransformedStream.subscribe({\n  next: (transformedData) =&gt; console.log(transformedData),\n  error: (err) =&gt; console.error(err),\n});\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamtoarray-promise","title":"observableStream.toArray() \u21d2 <code>Promise</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>Promise</code> - A promise that resolves with an array of all values emitted by the Observable Example <pre><code>// Example: Collecting all emitted values from an ObservableStream\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nnumberStream.toArray().then((values) =&gt; console.log(values)); // Logs: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamforeachcallback-promise","title":"observableStream.forEach(callback) \u21d2 <code>Promise</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>Promise</code> - A promise that resolves when the Observable completes  </p> Param Type Description callback <code>function</code> The function to call for each value emitted by the Observable <p>Example <pre><code>// Example: Logging each value emitted by an ObservableStream\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nnumberStream.forEach((value) =&gt; console.log(value)); // Logs each number from 0 to 9\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreameverypredicate-promise","title":"observableStream.every(predicate) \u21d2 <code>Promise</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>Promise</code> - A promise that resolves with a boolean indicating whether every value satisfies the predicate  </p> Param Type Description predicate <code>function</code> The function to test each value <p>Example <pre><code>// Example: Checking if all emitted values are even\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nnumberStream.every((value) =&gt; value % 2 === 0).then((allEven) =&gt; console.log(allEven)); // Logs: false\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamfindpredicate-promise","title":"observableStream.find(predicate) \u21d2 <code>Promise</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>Promise</code> - A promise that resolves with the first value that satisfies the predicate  </p> Param Type Description predicate <code>function</code> The function to test each value <p>Example <pre><code>// Example: Finding the first emitted value that is greater than 5\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nnumberStream.find((value) =&gt; value &gt; 5).then((value) =&gt; console.log(value)); // Logs: 6\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamsomepredicate-promise","title":"observableStream.some(predicate) \u21d2 <code>Promise</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>Promise</code> - A promise that resolves with a boolean indicating whether some value satisfies the predicate  </p> Param Type Description predicate <code>function</code> The function to test each value <p>Example <pre><code>// Example: Checking if any emitted values are greater than 5\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nnumberStream.some((value) =&gt; value &gt; 5).then((anyGreaterThan5) =&gt; console.log(anyGreaterThan5)); // Logs: true\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamfinallycallback-observablestream","title":"observableStream.finally(callback) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that calls the callback when it completes  </p> Param Type Description callback <code>function</code> The function to call when the Observable completes <p>Example <pre><code>// Example: Logging a message when the ObservableStream completes\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nconst finalStream = numberStream.finally(() =&gt; console.log('Stream completed'));\nfinalStream.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n}); // Logs each number from 0 to 9, then logs 'Stream completed'\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamtostate-observablestate","title":"observableStream.toState() \u21d2 <code>ObservableState</code>","text":"<p>Converts the ObservableStream to an ObservableState</p> <p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableState</code> - A new ObservableState that represents the current value of the stream Example <pre><code>// Example: Converting an ObservableStream to an ObservableState\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nconst numberState = numberStream.toState();\nnumberState.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n}); // Logs each number from 0 to 9\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreampushvalue","title":"observableStream.push(value)","text":"<p>Pushes a value to the observers. The value can be an Observable, an async iterable, an iterable, a Promise, or any other value.</p> <p>Kind: instance method of <code>ObservableStream</code> </p> Param Type Description value <code>any</code> The value to push <p>Example <pre><code>// Example 1: Pushing values from an Observable\nconst sourceStream = new ObservableStream();\nconst targetStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  sourceStream.push(i);\n}\nsourceStream.end();\ntargetStream.push(sourceStream);\ntargetStream.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n}); // Logs each number from 0 to 9\n\n// Example 2: Pushing values from a Promise\nconst promiseStream = new ObservableStream();\nconst promise = new Promise((resolve) =&gt; {\n  setTimeout(() =&gt; resolve('Hello, world!'), 1000);\n});\npromiseStream.push(promise);\npromiseStream.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n}); // Logs 'Hello, world!' after 1 second\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamplugstream","title":"observableStream.plug(stream)","text":"<p>Subscribes to a stream and pushes its values to the observers.</p> <p>Kind: instance method of <code>ObservableStream</code> </p> Param Type Description stream <code>ObservableStream</code> The stream to plug <p>Example <pre><code>// Example: Plugging one ObservableStream into another\nconst sourceStream = new ObservableStream();\nconst targetStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  sourceStream.push(i);\n}\nsourceStream.end();\ntargetStream.plug(sourceStream);\ntargetStream.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n}); // Logs each number from 0 to 9\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamend","title":"observableStream.end()","text":"<p>Ends the stream by calling the complete method of each observer.</p> <p>Kind: instance method of <code>ObservableStream</code> Example <pre><code>// Example: Ending an ObservableStream\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nnumberStream.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n  complete: () =&gt; console.log('Stream completed'),\n}); // Logs each number from 0 to 9, then logs 'Stream completed'\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamcatcherrorfn-observablestream","title":"observableStream.catchError(fn) \u21d2 <code>ObservableStream</code>","text":"<p>Catches errors on the ObservableStream and replaces them with a new stream.</p> <p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - - Returns a new ObservableStream that replaces the original stream when an error occurs.  </p> Param Type Description fn <code>function</code> A function that receives the error and returns a new ObservableStream. <p>Example <pre><code>// Example: Catching and handling errors in an ObservableStream\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  if (i === 5) {\n    numberStream.error(new Error('Something went wrong'));\n  } else {\n    numberStream.push(i);\n  }\n}\nnumberStream.end();\nconst errorHandledStream = numberStream.catchError((error) =&gt; {\n  console.error(error);\n  return new ObservableStream((subscriber) =&gt; {\n    subscriber.push('Error handled');\n    subscriber.complete();\n  });\n});\nerrorHandledStream.subscribe({\n  next: (value) =&gt; console.log(value),\n  error: (err) =&gt; console.error(err),\n}); // Logs each number from 0 to 4, logs the error, then logs 'Error handled'\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamdebouncedelay-observablestream","title":"observableStream.debounce(delay) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits the latest value after the debounce delay  </p> Param Type Description delay <code>number</code> The debounce delay in milliseconds <p>Example <pre><code>// Example: Debouncing an ObservableStream of click events\nconst clickStream = new ObservableStream();\ndocument.addEventListener('click', (event) =&gt; clickStream.push(event));\nconst debouncedStream = clickStream.debounce(500);\ndebouncedStream.subscribe({\n  next: (event) =&gt; console.log(`Clicked at position: ${event.clientX}, ${event.clientY}`),\n  error: (err) =&gt; console.error(err),\n}); // Logs the position of the last click event that occurred at least 500 milliseconds after the previous click event\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamtapsideeffectfn-observablestream","title":"observableStream.tap(sideEffectFn) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that is identical to the source  </p> Param Type Description sideEffectFn <code>function</code> The function to perform side effect <p>Example <pre><code>// Example: Logging each value emitted by an ObservableStream\nconst numberStream = new ObservableStream();\nfor (let i = 0; i &lt; 10; i++) {\n  numberStream.push(i);\n}\nnumberStream.end();\nconst loggedStream = numberStream.tap((value) =&gt; console.log(value));\nloggedStream.subscribe({\n  next: (value) =&gt; {},\n  error: (err) =&gt; console.error(err),\n}); // Logs each number from 0 to 9\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamthrottleduration-observablestream","title":"observableStream.throttle(duration) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits a value then ignores subsequent source values for duration milliseconds, then repeats this process.  </p> Param Type Description duration <code>number</code> The throttle duration in milliseconds <p>Example <pre><code>// Example 1: Throttling scroll events\nconst scrollStream = new ObservableStream(subscriber =&gt; {\n  window.addEventListener('scroll', event =&gt; subscriber.next(event));\n});\nconst throttledScrollStream = scrollStream.throttle(200);\nthrottledScrollStream.subscribe({\n  next: (event) =&gt; console.log('Scroll event:', event),\n  error: (err) =&gt; console.error(err),\n});\n\n// Example 2: Throttling search input for autocomplete\nconst searchInput = document.querySelector('#search-input');\nconst searchStream = new ObservableStream(subscriber =&gt; {\n  searchInput.addEventListener('input', event =&gt; subscriber.next(event.target.value));\n});\nconst throttledSearchStream = searchStream.throttle(300);\nthrottledSearchStream.subscribe({\n  next: (searchTerm) =&gt; console.log('Search term:', searchTerm),\n  error: (err) =&gt; console.error(err),\n});\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamdistinctuntilchanged-observablestream","title":"observableStream.distinctUntilChanged() \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits all items emitted by the source Observable that are distinct by comparison from the previous item. Example <pre><code>// Example 1: Filtering out consecutive duplicate search terms\nconst searchInput = document.querySelector('#search-input');\nconst searchStream = new ObservableStream(subscriber =&gt; {\n  searchInput.addEventListener('input', event =&gt; subscriber.next(event.target.value));\n});\nconst distinctSearchStream = searchStream.distinctUntilChanged();\ndistinctSearchStream.subscribe({\n  next: (searchTerm) =&gt; console.log('Search term:', searchTerm),\n  error: (err) =&gt; console.error(err),\n});\n\n// Example 2: Filtering out consecutive duplicate API responses\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst distinctDataStream = observableStream.distinctUntilChanged();\ndistinctDataStream.subscribe({\n  next: (data) =&gt; console.log('API data:', data),\n  error: (err) =&gt; console.error(err),\n});\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamconcatmaptransformfn-observablestream","title":"observableStream.concatMap(transformFn) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits the results of applying a given transform function to each value emitted by the source ObservableStream, sequentially.  </p> Param Type Description transformFn <code>function</code> The function to transform each value in the source ObservableStream <p>Example <pre><code>// Example 1: Transforming a stream of search terms into a stream of search results\nconst searchInput = document.querySelector('#search-input');\nconst searchStream = new ObservableStream(subscriber =&gt; {\n  searchInput.addEventListener('input', event =&gt; subscriber.next(event.target.value));\n});\nconst resultsStream = searchStream.concatMap(searchTerm =&gt;\n  ObservableStream.from(fetch(`https://api.example.com/search?query=${searchTerm}`).then(response =&gt; response.json()))\n);\nresultsStream.subscribe({\n  next: (results) =&gt; console.log('Search results:', results),\n  error: (err) =&gt; console.error(err),\n});\n\n// Example 2: Transforming a stream of click events into a stream of clicked elements\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event.target));\n});\nconst elementsStream = clickStream.concatMap(target =&gt;\n  ObservableStream.from(Promise.resolve(target))\n);\nelementsStream.subscribe({\n  next: (element) =&gt; console.log('Clicked element:', element),\n  error: (err) =&gt; console.error(err),\n});\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamcombinelatestobservables-observablestream","title":"observableStream.combineLatest(...observables) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits an array with the latest values from each source ObservableStream, whenever any source ObservableStream emits.  </p> Param Type Description ...observables <code>ObservableStream</code> The source ObservableStreams <p>Example <pre><code>// Example 1: Combining multiple API data streams\nconst apiDataStream1 = fetch('https://api.example.com/data1').then(response =&gt; response.json());\nconst apiDataStream2 = fetch('https://api.example.com/data2').then(response =&gt; response.json());\nconst observableStream1 = ObservableStream.from(apiDataStream1);\nconst observableStream2 = ObservableStream.from(apiDataStream2);\nconst combinedStream = observableStream1.combineLatest(observableStream2);\ncombinedStream.subscribe({\n  next: ([data1, data2]) =&gt; console.log('API data:', data1, data2),\n  error: (err) =&gt; console.error(err),\n});\n\n// Example 2: Combining multiple user event streams\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst scrollStream = new ObservableStream(subscriber =&gt; {\n  window.addEventListener('scroll', event =&gt; subscriber.next(event));\n});\nconst combinedStream = clickStream.combineLatest(scrollStream);\ncombinedStream.subscribe({\n  next: ([clickEvent, scrollEvent]) =&gt; console.log('User events:', clickEvent, scrollEvent),\n  error: (err) =&gt; console.error(err),\n});\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamstartwithinitialvalues-observablestream","title":"observableStream.startWith(...initialValues) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: instance method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits the specified initial values, followed by all values emitted by the source ObservableStream.  </p> Param Type Description ...initialValues <code>any</code> The initial values to start with <p>Example <pre><code>// Example 1: Prepending an API data stream with a loading state\nconst apiDataStream = fetch('https://api.example.com/data').then(response =&gt; response.json());\nconst observableStream = ObservableStream.from(apiDataStream);\nconst loadingStream = observableStream.startWith('loading');\nloadingStream.subscribe({\n  next: (state) =&gt; console.log('State:', state),\n  error: (err) =&gt; console.error(err),\n});\n\n// Example 2: Prepending a user event stream with an initial event\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst initialEvent = { type: 'initial' };\nconst eventStream = clickStream.startWith(initialEvent);\neventStream.subscribe({\n  next: (event) =&gt; console.log('Event:', event),\n  error: (err) =&gt; console.error(err),\n});\n</code></pre> </p>"},{"location":"api/observable_stream/#observablestreamfromvalue-observablestream","title":"ObservableStream.from(value) \u21d2 <code>ObservableStream</code>","text":"<p>Kind: static method of <code>ObservableStream</code> Returns: <code>ObservableStream</code> - A new ObservableStream that emits the values from the value  </p> Param Type Description value <code>any</code> The value to create an Observable from <p>Example <pre><code>// Example 1: Creating an ObservableStream from a user event stream\nconst clickStream = new ObservableStream(subscriber =&gt; {\n  document.addEventListener('click', event =&gt; subscriber.next(event));\n});\nconst observableStream = ObservableStream.from(clickStream);\n</code></pre></p>"},{"location":"api/reactive_element/","title":"Reactive element","text":""},{"location":"api/reactive_element/#classes","title":"Classes","text":"ReactiveElement"},{"location":"api/reactive_element/#typedefs","title":"Typedefs","text":"ObservableProperty ObservableState ObservableProxy"},{"location":"api/reactive_element/#reactiveelement","title":"ReactiveElement","text":"<p>Kind: global class  </p> <ul> <li>ReactiveElement<ul> <li>new ReactiveElement()</li> <li>.observableAttributes(attributes) \u21d2 <code>void</code></li> <li>.effect(effectFn) \u21d2 <code>void</code></li> <li>.connect(store, key) \u21d2 <code>ObservableProxy</code></li> <li>.stream(subscribeFn) \u21d2 <code>ObservableStream</code></li> <li>.template() \u21d2 <code>void</code></li> <li>.query(options) \u21d2 <code>ObservableProxy</code></li> <li>.mutation(options) \u21d2 <code>ObservableProxy</code></li> <li>.invalidateQueries(queryKey) \u21d2 <code>void</code></li> <li>.onCreate() \u21d2 <code>void</code></li> <li>.connectedCallback() \u21d2 <code>void</code></li> <li>.onConnect() \u21d2 <code>void</code></li> <li>.disconnectedCallback() \u21d2 <code>void</code> | <code>void</code></li> <li>.onDisconnect() \u21d2 <code>void</code></li> <li>.attributeChangedCallback(name, oldValue, newValue) \u21d2 <code>void</code></li> <li>.onAttributeChange() \u21d2 <code>void</code></li> <li>.adoptedCallback() \u21d2 <code>void</code> | <code>void</code></li> <li>.onAdopt() \u21d2 <code>void</code></li> </ul> </li> </ul> <p></p>"},{"location":"api/reactive_element/#new-reactiveelement","title":"new ReactiveElement()","text":"<p>This class is needed to create reactive web components that can automatically update their view when their state changes. All properties are automatically converted to observables. This is achieved by using creating an ObservableProperty, which provides a getter and setter for the property. The getter returns the current value of the property, and the setter updates the value of the property and triggers a re-render of the component.</p> <p>Example <pre><code>const { html, ReactiveElement } = cami;\n\nclass CounterElement extends ReactiveElement {\n  // Here, 'count' is automatically initialized as an ObservableProperty.\n  // This means that any changes to 'count' will automatically trigger a re-render of the component.\n  count = 0\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n      &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n      &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n    `;\n  }\n}\n\ncustomElements.define('counter-component', CounterElement);\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementobservableattributesattributes-void","title":"reactiveElement.observableAttributes(attributes) \u21d2 <code>void</code>","text":"<p>Creates ObservableProperty or ObservableProxy instances for all properties in the provided object.</p> <p>Kind: instance method of <code>ReactiveElement</code> </p> Param Type Description attributes <code>Object</code> An object with attribute names as keys and optional parsing functions as values. <p>Example <pre><code>// In _009_dataFromProps.html, the todos attribute is parsed as JSON and the data property is extracted:\nthis.observableAttributes({\n  todos: (v) =&gt; JSON.parse(v).data\n});\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementeffecteffectfn-void","title":"reactiveElement.effect(effectFn) \u21d2 <code>void</code>","text":"<p>Creates an effect and registers its dispose function. The effect is used to perform side effects in response to state changes. This method is useful when working with ObservableProperties or ObservableProxies because it triggers the effect whenever the value of the underlying ObservableState changes.</p> <p>Kind: instance method of <code>ReactiveElement</code> </p> Param Type Description effectFn <code>function</code> The function to create the effect <p>Example <pre><code>// Assuming `this.count` is an ObservableProperty\nthis.effect(() =&gt; {\n  console.log(`The count is now: ${this.count}`);\n});\n// The console will log the current count whenever `this.count` changes\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementconnectstore-key-observableproxy","title":"reactiveElement.connect(store, key) \u21d2 <code>ObservableProxy</code>","text":"<p>Subscribes to a store and creates an observable for a specific key in the store. This is useful for synchronizing the component's state with a global store.</p> <p>Kind: instance method of <code>ReactiveElement</code> Returns: <code>ObservableProxy</code> - An observable property or proxy for the store key  </p> Param Type Description store <code>ObservableStore</code> The store to subscribe to key <code>string</code> The key in the store to create an observable for <p>Example <pre><code>// Assuming there is a store for cart items\n// `cartItems` will be an observable reflecting the current state of cart items in the store\nthis.cartItems = this.connect(CartStore, 'cartItems');\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementstreamsubscribefn-observablestream","title":"reactiveElement.stream(subscribeFn) \u21d2 <code>ObservableStream</code>","text":"<p>Creates an ObservableStream from a subscription function.</p> <p>Kind: instance method of <code>ReactiveElement</code> Returns: <code>ObservableStream</code> - An ObservableStream that emits values produced by the subscription function.  </p> Param Type Description subscribeFn <code>function</code> The subscription function. <p>Example <pre><code>// In a FormElement component\nconst inputValidation$ = this.stream();\ninputValidation$\n  .map(e =&gt; this.validateEmail(e.target.value))\n  .debounce(300)\n  .subscribe(({ isEmailValid, emailError, email }) =&gt; {\n    this.emailError = emailError;\n    this.isEmailValid = isEmailValid;\n    this.email = email;\n    this.isEmailAvailable = this.queryEmail(this.email);\n  });\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementtemplate-void","title":"reactiveElement.template() \u21d2 <code>void</code>","text":"<p>Kind: instance method of <code>ReactiveElement</code> Throws:</p> <ul> <li><code>Error</code> If the method template() is not implemented</li> </ul> <p>Example <pre><code>// Here's a simple example of a template method implementation\ntemplate() {\n  return html`&lt;div&gt;Hello World&lt;/div&gt;`;\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementqueryoptions-observableproxy","title":"reactiveElement.query(options) \u21d2 <code>ObservableProxy</code>","text":"<p>Fetches data from an API and caches it. This method is based on the TanStack Query defaults: https://tanstack.com/query/latest/docs/react/guides/important-defaults.</p> <p>Kind: instance method of <code>ReactiveElement</code> Returns: <code>ObservableProxy</code> - A proxy that contains the state of the query.  </p> Param Type Default Description options <code>Object</code> The options for the query. options.queryKey <code>Array</code> | <code>string</code> The key for the query. options.queryFn <code>function</code> The function to fetch data. [options.staleTime] <code>number</code> <code>0</code> The stale time for the query. [options.refetchOnWindowFocus] <code>boolean</code> <code>true</code> Whether to refetch on window focus. [options.refetchOnMount] <code>boolean</code> <code>true</code> Whether to refetch on mount. [options.refetchOnReconnect] <code>boolean</code> <code>true</code> Whether to refetch on network reconnect. [options.refetchInterval] <code>number</code> <code></code> The interval to refetch data. [options.gcTime] <code>number</code> <code>1000 * 60 * 5</code> The garbage collection time for the query. [options.retry] <code>number</code> <code>3</code> The number of retry attempts. [options.retryDelay] <code>function</code> <code>(attempt) =&gt; Math.pow(2, attempt) * 1000</code> The delay before retrying a failed query. <p>Example <pre><code>// In _012_blog.html, a query is set up to fetch posts with a stale time of 5 minutes:\nconst posts = this.query({\n  queryKey: [\"posts\"],\n  queryFn: () =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts?_limit=5\").then(res =&gt; res.json()),\n  staleTime: 1000 * 60 * 5\n});\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementmutationoptions-observableproxy","title":"reactiveElement.mutation(options) \u21d2 <code>ObservableProxy</code>","text":"<p>Performs a mutation and returns an observable proxy. This method is inspired by the TanStack Query mutate method: https://tanstack.com/query/latest/docs/react/guides/mutations.</p> <p>Kind: instance method of <code>ReactiveElement</code> Returns: <code>ObservableProxy</code> - A proxy that contains the state of the mutation.  </p> Param Type Description options <code>Object</code> The options for the mutation. options.mutationFn <code>function</code> The function to perform the mutation. [options.onMutate] <code>function</code> The function to be called before the mutation is performed. [options.onError] <code>function</code> The function to be called if the mutation encounters an error. [options.onSuccess] <code>function</code> The function to be called if the mutation is successful. [options.onSettled] <code>function</code> The function to be called after the mutation has either succeeded or failed. <p>Example <pre><code>// In _012_blog.html, a mutation is set up to add a new post with optimistic UI updates:\nconst addPost = this.mutation({\n  mutationFn: (newPost) =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    method: \"POST\",\n    body: JSON.stringify(newPost),\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\"\n    }\n  }).then(res =&gt; res.json()),\n  onMutate: (newPost) =&gt; {\n    // Snapshot the previous state\n    const previousPosts = this.posts.data;\n    // Optimistically update to the new value\n    this.posts.update(state =&gt; {\n      state.data.push({ ...newPost, id: Date.now() });\n    });\n    // Return the rollback function and the new post\n    return {\n      rollback: () =&gt; {\n        this.posts.update(state =&gt; {\n          state.data = previousPosts;\n        });\n      },\n      optimisticPost: newPost\n    };\n  }\n});\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementinvalidatequeriesquerykey-void","title":"reactiveElement.invalidateQueries(queryKey) \u21d2 <code>void</code>","text":"<p>Invalidates the queries with the given key, causing them to refetch if needed. This method is particularly useful when used in conjunction with mutations, such as in the <code>onSettled</code> callback, to ensure that the UI reflects the latest state.</p> <p>Kind: instance method of <code>ReactiveElement</code> </p> Param Type Description queryKey <code>Array</code> | <code>string</code> The key for the query to invalidate. <p>Example <pre><code>// In a mutation's `onSettled` callback within a `BlogComponent`:\nthis.addPost = this.mutation({\n  // ...mutation config...\n  onSettled: () =&gt; {\n    // Invalidate the posts query to refetch the true state\n    this.invalidateQueries(['posts']);\n  }\n});\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementoncreate-void","title":"reactiveElement.onCreate() \u21d2 <code>void</code>","text":"<p>Called when the component is created. Can be overridden by subclasses to add initialization logic. This method is a hook for the connectedCallback, which is invoked each time the custom element is appended into a document-connected element.</p> <p>Kind: instance method of <code>ReactiveElement</code> Example <pre><code>onCreate() {\n  // Example initialization logic here\n  this.posts = this.query({\n    queryKey: [\"posts\"],\n    queryFn: () =&gt; {\n      return fetch(\"https://jsonplaceholder.typicode.com/posts?_limit=5\")\n        .then(res =&gt; res.json())\n    },\n    staleTime: 1000 * 60 * 5 // 5 minutes\n  });\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementconnectedcallback-void","title":"reactiveElement.connectedCallback() \u21d2 <code>void</code>","text":"<p>Invoked when the custom element is appended into a document-connected element. Sets up initial state and triggers initial rendering. This is typically used to initialize component state, fetch data, and set up event listeners.</p> <p>Kind: instance method of <code>ReactiveElement</code> Example <pre><code>// In a TodoList component\nconnectedCallback() {\n  super.connectedCallback();\n  this.fetchTodos(); // Fetch todos when the component is added to the DOM\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementonconnect-void","title":"reactiveElement.onConnect() \u21d2 <code>void</code>","text":"<p>Invoked when the custom element is connected to the document's DOM.</p> <p>Kind: instance method of <code>ReactiveElement</code> Returns: <code>void</code> - Subclasses can override this to add initialization logic when the component is added to the DOM. Example <pre><code>// In a UserCard component\nonConnect() {\n  this.showUserDetails(); // Display user details when the component is connected\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementdisconnectedcallback-void-void","title":"reactiveElement.disconnectedCallback() \u21d2 <code>void</code> | <code>void</code>","text":"<p>Invoked when the custom element is disconnected from the document's DOM. This is a good place to remove event listeners, cancel any ongoing network requests, or clean up any resources.</p> <p>Kind: instance method of <code>ReactiveElement</code> Example <pre><code>// In a Modal component\ndisconnectedCallback() {\n  super.disconnectedCallback();\n  this.close(); // Close the modal when it's disconnected from the DOM\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementondisconnect-void","title":"reactiveElement.onDisconnect() \u21d2 <code>void</code>","text":"<p>Invoked when the custom element is disconnected from the document's DOM. Subclasses can override this to add cleanup logic when the component is removed from the DOM.</p> <p>Kind: instance method of <code>ReactiveElement</code> Example <pre><code>// In a VideoPlayer component\nonDisconnect() {\n  this.stopPlayback(); // Stop video playback when the component is removed\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementattributechangedcallbackname-oldvalue-newvalue-void","title":"reactiveElement.attributeChangedCallback(name, oldValue, newValue) \u21d2 <code>void</code>","text":"<p>Invoked when an attribute of the custom element is added, removed, updated, or replaced. This can be used to react to attribute changes, such as updating the component state or modifying its appearance.</p> <p>Kind: instance method of <code>ReactiveElement</code> </p> Param Type Description name <code>string</code> The name of the attribute that changed oldValue <code>string</code> The old value of the attribute newValue <code>string</code> The new value of the attribute <p>Example <pre><code>// In a ThemeSwitcher component\nattributeChangedCallback(name, oldValue, newValue) {\n  super.attributeChangedCallback(name, oldValue, newValue);\n  if (name === 'theme') {\n    this.updateTheme(newValue); // Update the theme when the `theme` attribute changes\n  }\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementonattributechange-void","title":"reactiveElement.onAttributeChange() \u21d2 <code>void</code>","text":"<p>Invoked when an attribute of the custom element is added, removed, updated, or replaced.</p> <p>Kind: instance method of <code>ReactiveElement</code> Returns: <code>void</code> - Subclasses can override this to add logic that should run when an attribute changes. Example <pre><code>// In a CollapsiblePanel component\nonAttributeChange(name, oldValue, newValue) {\n  if (name === 'collapsed') {\n    this.toggleCollapse(newValue === 'true'); // Toggle collapse when the `collapsed` attribute changes\n  }\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementadoptedcallback-void-void","title":"reactiveElement.adoptedCallback() \u21d2 <code>void</code> | <code>void</code>","text":"<p>Invoked when the custom element is moved to a new document. This can be used to update bindings or perform re-initialization as needed when the component is adopted into a new DOM context.</p> <p>Kind: instance method of <code>ReactiveElement</code> Example <pre><code>// In a DragDropContainer component\nadoptedCallback() {\n  super.adoptedCallback();\n  this.updateDragDropContext(); // Update context when the component is moved to a new document\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#reactiveelementonadopt-void","title":"reactiveElement.onAdopt() \u21d2 <code>void</code>","text":"<p>Invoked when the custom element is moved to a new document. Subclasses can override this to add logic that should run when the component is moved to a new document.</p> <p>Kind: instance method of <code>ReactiveElement</code> Example <pre><code>// In a DataGrid component\nonAdopt() {\n  this.refreshData(); // Refresh data when the component is adopted into a new document\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#observableproperty","title":"ObservableProperty","text":"<p>Kind: global typedef Properties</p> Name Type Description get <code>function</code> A getter function that returns the current value of the property. If the property is a primitive value, this will return the value directly from the ObservableState instance. If the property is a non-primitive value, this will return an ObservableProxy that wraps the ObservableState instance. This getter is used when accessing the property on a ReactiveElement instance. This polymorphic behavior allows the ObservableProperty to handle both primitive and non-primitive values, and handle nested properties (only proxies can handle nested properties, whereas getters/setter traps cannot) set <code>function</code> A setter function that updates the value of the property. It updates the ObservableState instance with the new value. This setter is used when assigning a new value to the property on a ReactiveElement instance. <p>Example <pre><code>// Primitive value example from _001_counter.html\n// this.count is an ObservableProperty, where if you get the value, it returns the current value of the property, and if you set the value, it updates the property with the new value\n// ObservableProperty is just Object.defineProperty with a getter and setter, where the Object is the ReactiveElement instance\nclass CounterElement extends ReactiveElement {\n  count = 0\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n      &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n      &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n    `;\n  }\n}\n\n// Non-primitive value example from _003_todo.html\n// this.query returns an ObservableProperty / ObservableProxy\n// this.todos is an ObservableProxy, where if you get the value, it returns the current value of the property, and if you set the value, it updates the property with the new value\n// We use Proxy instead of Object.defineProperty because it allows us to handle nested properties\nclass TodoListElement extends ReactiveElement {\n  todos = this.query({\n    queryKey: ['todos'],\n    queryFn: () =&gt; {\n      return fetch(\"https://mockend.com/api/kennyfrc/cami-mock-api/todos?limit=5\").then(res =&gt; res.json())\n    },\n    staleTime: 1000 * 60 * 5 // 5 minutes\n  })\n\n  template() {\n    // ...template code...\n  }\n}\n\n// Array value example from _010_taskmgmt.html\n// this.tasks is an ObservableProxy, where if you get the value, it returns the current value of the property, and if you set the value, it updates the property with the new value\n// We use Proxy instead of Object.defineProperty because it allows us to handle nested properties\nclass TaskManagerElement extends ReactiveElement {\n  tasks = [];\n  filter = 'all';\n\n  // ...other methods...\n\n  template() {\n    // ...template code...\n  }\n}\n</code></pre> </p>"},{"location":"api/reactive_element/#observablestate","title":"ObservableState","text":"<p>Kind: global typedef Properties</p> Name Type Description value <code>any</code> The current value of the observable state. This is the value that is returned when accessing a primitive property on a ReactiveElement instance. It can also be used to set a new value for the observable state. update <code>function</code> A function that updates the value of the observable state. It takes an updater function that receives the current value and returns the new value. This is used when assigning a new value to a primitive property on a ReactiveElement instance. It allows deeply nested updates. [dispose] <code>function</code> An optional function that cleans up the observable state when it is no longer needed. This is used internally by ReactiveElement to manage memory. <p></p>"},{"location":"api/reactive_element/#observableproxy","title":"ObservableProxy","text":"<p>Kind: global typedef Properties</p> Name Type Description get <code>function</code> A getter function that returns the current value of the property. If the property is a primitive value, this will return the value directly from the ObservableState instance. If the property is a non-primitive value, this will return an ObservableProxy that wraps the ObservableState instance. This getter is used when accessing a non-primitive property on a ReactiveElement instance. We use Proxy instead of Object.defineProperty because it allows us to handle nested properties. set <code>function</code> A setter function that updates the value of the property. It updates the ObservableState instance with the new value. This setter is used when assigning a new value to a non-primitive property on a ReactiveElement instance."},{"location":"blog/","title":"Blog","text":"<p>tbc</p>"},{"location":"features/async_state_management/","title":"Asynchronous Server State Management","text":"<p>Cami provides a powerful async state management system that allows components to fetch and manage asynchronous data with ease. Here's how it works:</p>"},{"location":"features/async_state_management/#queries","title":"Queries","text":"<p>Queries are used to fetch data asynchronously and serve it to your components. They are defined with a <code>queryKey</code>, a unique identifier for the query's data in the internal cache, and a <code>queryFn</code>, a function that fetches the data. The result of a query is an observable object that automatically updates its <code>data</code>, <code>status</code>, and <code>error</code> keys based on the query's execution, allowing you to declaratively render UI based on the state of the asynchronous operation.</p> <p>Here's an example of defining a query in a component and using it to render UI:</p> <pre><code>posts = this.query({\n  queryKey: [\"posts\"],\n  queryFn: () =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\").then(res =&gt; res.json()),\n  staleTime: 1000 * 60 * 5 // Optional: data is considered fresh for 5 minutes\n});\n\ntemplate() {\n  if (this.posts.status === \"loading\") {\n    return html`&lt;div&gt;Loading...&lt;/div&gt;`;\n  }\n\n  if (this.posts.status === \"error\") {\n    return html`&lt;div&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n  }\n\n  if (this.posts.data) {\n    return html`\n      &lt;ul&gt;\n        ${this.posts.data.map(post =&gt; html`\n          &lt;li&gt;\n            &lt;h2&gt;${post.title}&lt;/h2&gt;\n            &lt;p&gt;${post.body}&lt;/p&gt;\n          &lt;/li&gt;\n        `)}\n      &lt;/ul&gt;\n    `;\n  }\n}\n</code></pre> <p>Queries automatically refetch data to prevent it from becoming stale. However, you can control this behavior with the <code>staleTime</code> parameter, which defines how long the data should remain fresh before a refetch is required. The observable object returned by the query allows for a reactive connection between the data and the component's template, enabling the UI to update automatically when the query's state changes.</p> <p>When a component is added to the DOM, we can start fetching data by using the <code>onConnect()</code> method. This method is similar to the <code>connectedCallback()</code> used in Web Components, which you can read more about on MDN. Inside <code>onConnect()</code>, we call a function like <code>fetchPosts()</code> to load our data.</p> <p>For displaying the data, we can create a separate method like <code>renderPosts()</code> and call it inside our <code>template()</code> method. This helps us keep our code organized and makes it easier to manage different parts of our component.</p> <p>Here's how you can structure the component:</p> <pre><code>class BlogPostsElement extends ReactiveElement {\n  posts = {}\n\n  onConnect() {\n    this.fetchPosts();\n  }\n\n  fetchPosts() {\n    this.posts = this.query({\n      queryKey: ['posts', { limit }],\n      queryFn: () =&gt; fetch(`https://jsonplaceholder.typicode.com/posts?_limit=5`).then(res =&gt; res.json())\n    });\n  }\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.fetchPosts()}&gt;Refetch Posts&lt;/button&gt;\n      ${this.renderPosts()}\n    `;\n  }\n\n  renderPosts() {\n    if (this.posts.status === \"loading\") {\n      return html`&lt;div class=\"md-loader\"&gt;Loading...&lt;/div&gt;`;\n    }\n\n    if (this.posts.status === \"error\") {\n      return html`&lt;div class=\"md-error\"&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n    }\n\n    if (this.posts.data) {\n      return html`\n        &lt;div class=\"md-card\"&gt;\n          &lt;ul class=\"md-list\"&gt;\n            ${this.posts.data.map(post =&gt; html`\n              &lt;li class=\"md-list-item\"&gt;\n                &lt;h5 class=\"md-title\"&gt;${post.title}&lt;/h5&gt;\n                &lt;p class=\"md-body-1\"&gt;${post.body}&lt;/p&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        &lt;/div&gt;\n      `;\n    }\n  }\n}\n</code></pre> <p>This way, the <code>onConnect()</code> method is used to start the data fetching process, and the <code>renderPosts()</code> method is used to handle the display of the posts, keeping the code clean and easy to understand.</p>"},{"location":"features/async_state_management/#live-demo-of-query","title":"Live Demo of Query","text":"<p>Below is a live demo of the component in action. The only change is that we're fetching a random number of posts between 1 and 5 just so you can see states change.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/async_state_management/#mutations","title":"Mutations","text":"<p>Mutations are used to modify server-side data and reflect those changes in the UI. They are defined with a <code>mutationFn</code>, which performs the update.</p> <p>Here's an example of defining a mutation in a component:</p> <pre><code>addPost = this.mutation({\n  mutationFn: (newPost) =&gt; fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n    method: \"POST\",\n    body: JSON.stringify(newPost),\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\"\n    }\n  }).then(res =&gt; res.json())\n});\n</code></pre> <p>This mutation submits a POST request to the server, and the component's UI can declaratively show various loading and error states. For example, you can display a loading message while the request is pending and an error message if the request fails, as shown below:</p> <pre><code>if (this.addPost.status === \"pending\") {\n  return html`\n    &lt;div&gt;Adding post...&lt;/div&gt;\n  `;\n}\n\nif (this.addPost.status === \"error\") {\n  return html`&lt;div&gt;Error: ${this.addPost.error.message}&lt;/div&gt;`;\n}\n</code></pre> <p>By using mutations, Cami enables developers to handle server-side updates in a consistent and powerful way, similar to how queries are used for fetching data.</p>"},{"location":"features/async_state_management/#live-demo-of-mutations","title":"Live Demo of Mutations","text":"<p>This live demo includes a form to submit a new post, which uses a mutation to update the server-side data. The mutation is defined in the <code>BlogPostsElement</code> class, and it handles the post submission process. The UI reflects the state of the mutation, showing a loading message while the request is pending and an error message if the request fails.</p> Blog Posts Component <p>The data fetches a random number of posts between 1 and 5 just so you can see states change.</p>"},{"location":"features/client_state_management/","title":"Cross-Component Client State Management","text":"<p>In Cami, cross-component state management is achieved through the use of stores. A store is a reactive state container that components can connect to and interact with. By default, Cami's store uses localStorage to persist state with an expiry of 24 hours, ensuring that the state is maintained across browser sessions. This expiry is configurable by passing a configuration object with an <code>expiry</code> property to the store.</p> <p>Here's an example of defining a store with a custom expiry and using it in two components:</p> <pre><code>const CartStore = cami.store({\n  cartItems: [],\n  add: (store, product) =&gt; {\n    const cartItem = { ...product, cartItemId: Date.now() };\n    store.cartItems.push(cartItem);\n  },\n  remove: (store, product) =&gt; {\n    store.cartItems = store.cartItems.filter(item =&gt; item.cartItemId !== product.cartItemId);\n  }\n}, { expiry: 1000 * 60 * 60 * 24 }); // 24 hours\n\nclass ProductListElement extends ReactiveElement {\n  cartItems = this.connect(CartStore, 'cartItems');\n  // ...\n}\n\nclass CartElement extends ReactiveElement {\n  cartItems = this.connect(CartStore, 'cartItems');\n  // ...\n}\n</code></pre> <p>Above, both <code>ProductListElement</code> and <code>CartElement</code> connect to <code>CartStore</code>. When a product is added or removed in <code>ProductListElement</code>, the changes are reflected in <code>CartElement</code> because they both share the same state from <code>CartStore</code>. The store's expiry is set to 24 hours, after which the state will no longer be persisted.</p> <p>The <code>ProductListElement</code> is initialized with a <code>query</code> that fetches product data from an API. This data is used to populate the <code>products</code> property. The <code>query</code> is configured with a <code>staleTime</code> of 5 minutes, indicating that the fetched data will be considered fresh for this duration before a new fetch is triggered.</p> <p>The <code>ProductListElement</code> also includes methods to add products to the cart, check if a product is already in the cart, and determine if a product is out of stock. The <code>template</code> method defines the HTML structure for the component, including a loading state, error handling, and the list of products with an \"Add to cart\" button that is disabled if the product is out of stock.</p> <p>Here is the relevant code for <code>ProductListElement</code>: <pre><code>  class ProductListElement extends ReactiveElement {\n    cartItems = this.connect(CartStore, 'cartItems');\n    products = this.query({\n      queryKey: ['products'],\n      queryFn: () =&gt; {\n        return fetch(\"https://mockend.com/api/kennyfrc/cami-mock-api/products?limit=3\").then(res =&gt; res.json())\n      },\n      staleTime: 1000 * 60 * 5 // 5 minutes\n    });\n\n    addToCart(product) {\n      CartStore.add(product);\n    }\n\n    isProductInCart(product) {\n      return this.cartItems ? this.cartItems.some(item =&gt; item.id === product.id) : false;\n    }\n\n    isOutOfStock(product) {\n      return product.stock === 0;\n    }\n\n    template() {\n      if (this.products.status === \"pending\") {\n        return html`&lt;div&gt;Loading...&lt;/div&gt;`;\n      }\n\n      if (this.products.status === \"error\") {\n        return html`&lt;div&gt;Error: ${this.products.error.message}&lt;/div&gt;`;\n      }\n\n      if (this.products.data) {\n        return html`\n          &lt;ul&gt;\n            ${this.products.data.map(product =&gt; html`\n              &lt;li&gt;\n                ${product.name} - $${(product.price / 100).toFixed(2)}\n                &lt;button @click=${() =&gt; this.addToCart(product)} ?disabled=${this.isOutOfStock(product)}&gt;\n                  Add to cart\n                &lt;/button&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        `;\n      }\n    }\n  }\n\n  customElements.define('product-list-component', ProductListElement);\n</code></pre></p> <p>This example demonstrates how <code>ProductListElement</code> interacts with <code>CartStore</code> and manages its own local state and UI rendering logic.</p> <p>Lastly, we then add the cart component to the page:</p> <p>The way this works is that <code>CartElement</code> extends <code>ReactiveElement</code> to create a reactive cart component. It connects to <code>CartStore</code> to listen for changes in the cart items and defines a getter <code>cartValue</code> to calculate the total value of the cart. It also includes a method <code>removeFromCart</code> to handle the removal of items from the cart. The <code>template</code> method returns the HTML structure for the cart, including the total cart value and a list of items with remove buttons.</p> <pre><code>  class CartElement extends ReactiveElement {\n    cartItems = this.connect(CartStore, 'cartItems');\n\n    get cartValue() {\n      return this.cartItems.reduce((acc, item) =&gt; acc + item.price, 0);\n    }\n\n    removeFromCart(product) {\n      CartStore.remove(product);\n    }\n\n    template() {\n      return html`\n        &lt;p&gt;Cart value: $${(this.cartValue / 100).toFixed(2)}&lt;/p&gt;\n        &lt;ul&gt;\n          ${this.cartItems.map(item =&gt; html`\n            &lt;li&gt;${item.name} - $${(item.price / 100).toFixed(2)} &lt;button @click=${() =&gt; this.removeFromCart(item)}&gt;Remove&lt;/button&gt;&lt;/li&gt;\n          `)}\n        &lt;/ul&gt;\n      `;\n    }\n  }\n\n  customElements.define('cart-component', CartElement);\n</code></pre> <p>Below is the live demo.</p>"},{"location":"features/client_state_management/#live-demo-cross-component-state-management","title":"Live Demo - Cross-Component State Management","text":"Products <p>This fetches the products from an API, and uses a client-side store to manage the cart. After adding a product to the cart, you can refresh the page and the cart will still be there as we are persisting the cart to localStorage, which is what you want in a cart.</p> Product List Cart"},{"location":"features/features/","title":"Feature Overview","text":"<ul> <li>Reactive Web Components: Simplifies front-end web development with <code>ReactiveElement</code>. This is done through Observable Properties. They are properties of a <code>ReactiveElement</code> instance that are automatically observed for changes. When a change occurs, the <code>ReactiveElement</code> instance is notified and can react accordingly by re-rendering the component. Observable properties support deep updates, array changes, and reactive attributes, making it easier to manage dynamic content. Lastly, this removes the boilerplate of <code>signal()</code>, <code>setState()</code>, or <code>reactive()</code> that you might find in other libraries.</li> <li>Async State Management: Easily manage server data. Our library provides a simple API for fetching and updating data with <code>query</code> and <code>mutation</code>. Use the <code>query</code> method to fetch and cache data, with options to control how often it refreshes. The <code>mutation</code> method lets you update data and immediately reflect those changes in the UI, providing a smooth experience without waiting for server responses.</li> <li>Cross-component State Management with  Stores: Share state across different components with ease using a single store using <code>cami.store</code>. By default, this uses <code>localStorage</code> to persist state across page refreshes. This is useful for storing user preferences, authentication tokens, and other data that needs to be shared across components. This is also useful for storing data that needs to be shared across tabs.</li> <li>Streams &amp; Functional Reactive Programming (FRP): Handle asynchronous events gracefully with Observable Streams. They offer powerful functions like <code>map</code>, <code>filter</code>, <code>flatMap</code>, and <code>debounce</code> to process events in a sophisticated yet manageable way, for clean &amp; declarative code.</li> </ul> Internals that You Don't Need to Worry About <ul> <li>Caching, Refetching, and Stale Data Handling for Server-side State: Keep your data fresh with automatic caching and refetching. Our library automatically caches data and refetches it when needed, so you don't have to worry about stale data.</li> <li>Automatic Expiry of Client-Side State: Keep your client-side state fresh with automatic expiry. Our store automatically expires state after a configurable duration (default is 24 hours), so you don't have to worry about stale data.</li> <li>Dependency Tracking: Keep your app's data in sync automatically. Our dependency tracker observes the relationships between your data and updates them as needed, so you can focus on writing the logic that matters.</li> <li>Automatic Disposal &amp; Garbage Collection: Avoid memory leaks with automatic disposal. Our library automatically disposes of streams, dependencies, and effects when they are no longer needed, so you don't have to worry about it.</li> </ul>"},{"location":"features/observable_property/","title":"Core Concepts: Observable Properties, Observable State, and Observable Proxy","text":""},{"location":"features/observable_property/#foundational-concepts","title":"Foundational Concepts","text":"<p>Before we dive into the Core Concepts, we need to understand a few foundational ideas first. I suggest reading the following links before continuing:</p> <ul> <li>Object.defineProperty</li> <li>Proxy</li> <li>Template Literals</li> <li>Observer Pattern</li> </ul>"},{"location":"features/observable_property/#observable-properties","title":"Observable Properties","text":"<p>Observable Properties are a key idea in Cami, building upon the foundational concepts mentioned above. These properties belong to instances of the ReactiveElement class and are automatically monitored for any changes.</p> <p>When a change is detected in an Observable Property (e.g. <code>this.count++</code>), the ReactiveElement instance is informed and triggers a re-rendering of the <code>template()</code> method's return value. This template method returns a template literal (e.g. <code>&lt;p&gt;Count: ${this.count}&lt;/p&gt;</code>), which is then parsed then rendered to the DOM.</p> <p>If you're familiar with React, you can think of tagged template literals as similar to JSX. The rendering process, akin to React's <code>render()</code> method, is automatically handled by the ReactiveElement instance when an Observable Property changes. This automatic re-rendering is a manifestation of the Observer Pattern, where the ReactiveElement instance acts as the observer, reacting to changes in the Observable Properties.</p>"},{"location":"features/observable_property/#counter-example-observable-properties-primitive-values","title":"Counter Example (Observable Properties &amp; Primitive Values)","text":"<p>Here is an example of an Observable Property in a ReactiveElement class: <pre><code>class CounterElement extends ReactiveElement {\n  count = 0\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n      &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n      &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n    `;\n  }\n}\n</code></pre></p> Counter Demo"},{"location":"features/observable_property/#how-it-works","title":"How it works","text":"<p>Under the hood, the Observable Property is created using <code>Object.defineProperty</code> with a getter and setter. The getter function returns the current value of the property. If the property is a primitive value, this will return the value directly from the ObservableState instance. If the property is a non-primitive value, this will return an ObservableProxy that wraps the ObservableState instance. This polymorphic behavior allows the ObservableProperty to handle both primitive and non-primitive values, and handle nested properties.</p> <p>The setter function updates the value of the property. It updates the ObservableState instance with the new value. This setter is used when assigning a new value to the property on a ReactiveElement instance. When the setter is called, it triggers a re-render of the component.</p> <p>In our example earlier, <code>count</code> is an Observable Property. Any changes to <code>count</code> will automatically trigger a re-render of the component.</p>"},{"location":"features/observable_property/#how-it-works-more-intuitively","title":"How it works (More Intuitively)","text":"<p>That's a lot of abstractions, but you can think of it this way:</p> <ul> <li>For a given primitive (e.g. number, string, boolean), this gets converted into an ObservableState instance. ObservableState instances are wrapper objects with <code>.value</code> getters/setters. And to make it easier to use, we wrap the ObservableState instance with an ObservableProperty, which is just an <code>Object.defineProperty</code> with a getter and setter, you can then just call <code>this.count</code> to get the value, and <code>this.count = 1</code> to set the value.</li> <li>For a given non-primitive (e.g. object, array), this gets converted into an ObservableState instance. ObservableState instances are wrapper objects with <code>.value</code> getters/setters. And to make it easier to use, we wrap the ObservableState instance with an ObservableProxy, which is just a Proxy object with a getter and setter, you can then just call <code>this.todos</code> to get the value, and <code>this.todos = []</code> to set the value. The reason we use Proxy instead of Object.defineProperty is because Proxy allows us to handle nested properties.</li> </ul>"},{"location":"features/observable_property/#task-manager-example-observable-properties-non-primitive-values","title":"Task Manager Example (Observable Properties &amp; Non-Primitive Values)","text":"<p>Observable Properties can also handle non-primitive values and nested properties. This is achieved by returning an ObservableProxy instead of the value directly. The ObservableProxy wraps the ObservableState instance and allows for nested properties to be observed. Here is an example: <pre><code>class TaskManagerElement extends ReactiveElement {\n  tasks = [];\n  filter = 'all';\n\n  // ...other methods...\n\n  template() {\n    // ...template code...\n  }\n}\n</code></pre></p> <p>In this example, <code>tasks</code> is an Observable Property that is an array. Any changes to the <code>tasks</code> array or any of its elements will automatically trigger a re-render of the component.</p> Simple Task Manager Demo (In-Memory Data) <p>Below is the API Reference for Observable Properties. Updated version is at the API Reference.</p>"},{"location":"features/observable_property/#observableproperty","title":"ObservableProperty","text":"<p>Kind: global typedef Properties</p> Name Type Description get <code>function</code> A getter function that returns the current value of the property. If the property is a primitive value, this will return the value directly from the ObservableState instance. If the property is a non-primitive value, this will return an ObservableProxy that wraps the ObservableState instance. This getter is used when accessing the property on a ReactiveElement instance. This polymorphic behavior allows the ObservableProperty to handle both primitive and non-primitive values, and handle nested properties (only proxies can handle nested properties, whereas getters/setter traps cannot) set <code>function</code> A setter function that updates the value of the property. It updates the ObservableState instance with the new value. This setter is used when assigning a new value to the property on a ReactiveElement instance. <p>Example <pre><code>// Primitive value example from _001_counter.html\n// this.count is an ObservableProperty, where if you get the value, it returns the current value of the property, and if you set the value, it updates the property with the new value\n// ObservableProperty is just Object.defineProperty with a getter and setter, where the Object is the ReactiveElement instance\nclass CounterElement extends ReactiveElement {\n  count = 0\n\n  template() {\n    return html`\n      &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n      &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n      &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n    `;\n  }\n}\n\n// Non-primitive value example from _003_todo.html\n// this.query returns an ObservableProperty / ObservableProxy\n// this.todos is an ObservableProxy, where if you get the value, it returns the current value of the property, and if you set the value, it updates the property with the new value\n// We use Proxy instead of Object.defineProperty because it allows us to handle nested properties\nclass TodoListElement extends ReactiveElement {\n  todos = this.query({\n    queryKey: ['todos'],\n    queryFn: () =&gt; {\n      return fetch(\"https://mockend.com/api/kennyfrc/cami-mock-api/todos?limit=5\").then(res =&gt; res.json())\n    },\n    staleTime: 1000 * 60 * 5 // 5 minutes\n  })\n\n  template() {\n    // ...template code...\n  }\n}\n\n// Array value example from _010_taskmgmt.html\n// this.tasks is an ObservableProxy, where if you get the value, it returns the current value of the property, and if you set the value, it updates the property with the new value\n// We use Proxy instead of Object.defineProperty because it allows us to handle nested properties\nclass TaskManagerElement extends ReactiveElement {\n  tasks = [];\n  filter = 'all';\n\n  // ...other methods...\n\n  template() {\n    // ...template code...\n  }\n}\n</code></pre> </p>"},{"location":"features/observable_property/#observablestate","title":"ObservableState","text":"<p>Kind: global typedef Properties</p> Name Type Description value <code>any</code> The current value of the observable state. This is the value that is returned when accessing a primitive property on a ReactiveElement instance. It can also be used to set a new value for the observable state. update <code>function</code> A function that updates the value of the observable state. It takes an updater function that receives the current value and returns the new value. This is used when assigning a new value to a primitive property on a ReactiveElement instance. It allows deeply nested updates. [dispose] <code>function</code> An optional function that cleans up the observable state when it is no longer needed. This is used internally by ReactiveElement to manage memory. <p></p>"},{"location":"features/observable_property/#observableproxy","title":"ObservableProxy","text":"<p>Kind: global typedef Properties</p> Name Type Description get <code>function</code> A getter function that returns the current value of the property. If the property is a primitive value, this will return the value directly from the ObservableState instance. If the property is a non-primitive value, this will return an ObservableProxy that wraps the ObservableState instance. This getter is used when accessing a non-primitive property on a ReactiveElement instance. We use Proxy instead of Object.defineProperty because it allows us to handle nested properties. set <code>function</code> A setter function that updates the value of the property. It updates the ObservableState instance with the new value. This setter is used when assigning a new value to a non-primitive property on a ReactiveElement instance."},{"location":"features/reactive_web_components/","title":"Automatic Reactivity in Web Components","text":"<p>Let's take the example of creating a counter component. In contrast to other frameworks where you might need to define a counter with something like <code>count = signal(0)</code> or <code>count = ref(0)</code>, and then retrieve the value with <code>count()</code> or <code>count.value</code>, Cami.js simplifies this process significantly.</p> <p>You can directly define <code>count = 0</code> within your <code>CounterElement</code> class and access it just like a regular JavaScript variable.</p> <p>Define a <code>CounterElement</code> class that extends <code>ReactiveElement</code> and define a <code>count</code> property initialized to 0:</p> <pre><code>class CounterElement extends ReactiveElement {\n  count = 0;\n  // ...\n}\n</code></pre> <p>Then define a <code>template</code> method that returns an HTML template using the <code>html</code> function:</p> <pre><code>template() {\n  return html`\n    &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n    &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n    &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n  `;\n}\n</code></pre> <p>Finally, register your custom element.</p> <pre><code>customElements.define('counter-component', CounterElement);\n</code></pre> <p>Add the element to your HTML file:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n</code></pre> <p>This is how everything comes together:</p> <pre><code>&lt;counter-component&gt;&lt;/counter-component&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0;\n    template() {\n      return html`\n        &lt;button @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"features/reactive_web_components/#live-demo-of-reactive-web-components-simple-counter","title":"Live Demo of Reactive Web Components (Simple Counter)","text":"<p>Now, when you load your HTML file, you will see a counter with two buttons to increment and decrement the count. The count is displayed and updated in real-time as you click the buttons.</p>"},{"location":"features/streams/","title":"Streams","text":"<p>In Cami.js, streams provide a way to handle asynchronous events in a reactive manner. This means you can write code that responds to events as they happen, rather than checking for them at regular intervals.</p> <p>A stream in Cami.js is essentially a sequence of asynchronous events. You can think of it as an array that populates over time. Each event in the stream represents a change in state.</p> <p>Here's an example of how you might use a stream in a Cami.js component. Let's say we want to create an interactive registration from that:</p> <ul> <li>Validates the email input as the user types</li> <li>Checks if the email is available</li> <li>Validates the password input as the user types</li> <li>Displays an error message if the password is too short</li> <li>Displays an error message if the email is not available</li> <li>Disables the submit button if the form is invalid</li> <li>Enables the submit button if the form is valid</li> </ul> <p>Here's how that registration form might look like. The button is disabled by default, and will enable if email &amp; password are valid.</p>"},{"location":"features/streams/#demo-registration-form","title":"Demo - Registration Form","text":"Try entering an email that is already taken, such as geovanniheaney@block.info (this is a mock email in our API) <p> <p></p> <p>Hope the example is motivating :) As the code can be a bit of a doozy. Explanation is right after the code.</p> <pre><code>&lt;article&gt;\n  &lt;h1&gt;Registration Form&lt;/h1&gt;\n  &lt;form-component&gt;&lt;/form-component&gt;\n&lt;/article&gt;\n&lt;small&gt;\n&lt;p&gt;Try entering an email that is already taken, such as geovanniheaney@block.info (mock email)&lt;/p&gt;\n&lt;/small&gt;\n&lt;script src=\"./build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;!-- CDN version below --&gt;\n&lt;!-- &lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt; --&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class FormElement extends ReactiveElement {\n    emailError = ''\n    passwordError = ''\n    email = '';\n    password = '';\n    emailIsValid = null;\n    isEmailAvailable = null;\n\n    inputValidation$ = this.stream();\n    passwordValidation$ = this.stream();\n\n    onConnect() {\n      this.inputValidation$\n        .map(e =&gt; this.validateEmail(e.target.value))\n        .debounce(300)\n        .subscribe(({ isEmailValid, emailError, email }) =&gt; {\n          this.emailError = emailError;\n          this.isEmailValid = isEmailValid;\n          this.email = email;\n          this.isEmailAvailable = this.queryEmail(this.email)\n        });\n\n      this.passwordValidation$\n        .map(e =&gt; this.validatePassword(e.target.value))\n        .debounce(300)\n        .subscribe(({ isValid, password }) =&gt; {\n          this.passwordError = isValid ? '' : 'Password must be at least 8 characters long.';\n          this.password = password;\n        });\n    }\n\n    validateEmail(email) {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      let emailError = '';\n      let isEmailValid = null;\n      if (email === '') {\n        emailError = '';\n        isEmailValid = null;\n      } else if (!emailRegex.test(email)) {\n        emailError = 'Please enter a valid email address.';\n        isEmailValid = false;\n      } else {\n        emailError = '';\n        isEmailValid = true;\n      }\n      return { isEmailValid, emailError, email };\n    }\n\n    validatePassword(password) {\n      let isValid = false;\n      if (password === '') {\n        isValid = null;\n      } else if (password?.length &gt;= 8) {\n        isValid = true;\n      }\n\n      return { isValid, password }\n    }\n\n    queryEmail(email) {\n      return this.query({\n        queryKey: ['Email', email],\n        queryFn: () =&gt; {\n          return fetch(`https://mockend.com/api/kennyfrc/cami-mock-api/users?email_eq=${email}`).then(res =&gt; res.json())\n        },\n        staleTime: 1000 * 60 * 5\n      })\n    }\n\n    getEmailInputState() {\n      if (this.email === '') {\n        return '';\n      } else if (this.isEmailValid &amp;&amp; this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length === 0) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    getPasswordInputState() {\n      if (this.password === '') {\n        return '';\n      } else if (this.passwordError === '') {\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    template() {\n      return html`\n        &lt;form action=\"/submit\" method=\"POST\"&gt;\n          &lt;label&gt;\n            Email:\n            &lt;input type=\"email\"\n              aria-invalid=${this.getEmailInputState()}\n              @input=${(e) =&gt; this.inputValidation$.next(e) } value=${this.email}&gt;\n              &lt;span&gt;${this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length &gt; 0 &amp;&amp; this.emailError === '' ? 'Email is already taken.' : ''}&lt;/span&gt;\n            &lt;span&gt;${this.emailError}&lt;/span&gt;\n          &lt;/label&gt;\n          &lt;label&gt;\n            Password:\n            &lt;input type=\"password\" @input=${(e) =&gt; this.passwordValidation$.next(e) }\n              value=${this.password}\n              aria-invalid=${this.getPasswordInputState()}&gt;\n            &lt;span&gt;${this.passwordError}&lt;/span&gt;\n          &lt;/label&gt;\n          &lt;input type=\"submit\" value=\"Submit\" ?disabled=${this.emailError !== '' || this.passwordError !== '' || this.email === '' || this.password === ''}&gt;\n        &lt;/form&gt;\n      `;\n    }\n  }\n\n  customElements.define('form-component', FormElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"features/streams/#explanation","title":"Explanation","text":"<p>This section provides a detailed explanation of the form component's code structure and functionality. Here's a step-by-step breakdown:</p>"},{"location":"features/streams/#starting-with-basic-html-structure","title":"Starting with Basic HTML Structure","text":"<p>The initial template is a simple HTML form with placeholders for dynamic content:</p> <pre><code>template() {\n  return html`\n    &lt;form action=\"/submit\" method=\"POST\"&gt;\n      &lt;label&gt;\n        Email:\n        &lt;input type=\"email\" aria-invalid=\"\" value=\"\"&gt;\n        &lt;span&gt;&lt;/span&gt; &lt;!-- Placeholder for email availability message --&gt;\n        &lt;span&gt;&lt;/span&gt; &lt;!-- Placeholder for email error message --&gt;\n      &lt;/label&gt;\n      &lt;label&gt;\n        Password:\n        &lt;input type=\"password\" value=\"\" aria-invalid=\"\"&gt;\n        &lt;span&gt;&lt;/span&gt; &lt;!-- Placeholder for password error message --&gt;\n      &lt;/label&gt;\n      &lt;input type=\"submit\" value=\"Submit\" disabled&gt;\n    &lt;/form&gt;\n  `;\n}\n</code></pre>"},{"location":"features/streams/#integrating-observables","title":"Integrating Observables","text":"<p>Observables are used to manage the state of the form, including error messages and input values:</p> <pre><code>const { html, ReactiveElement } = cami;\n\nclass FormElement extends ReactiveElement {\n  emailError = '';\n  passwordError = '';\n  email = '';\n  password = '';\n  emailIsValid = null;\n  isEmailAvailable = null;\n  // ...\n}\n</code></pre>"},{"location":"features/streams/#enhancing-the-template-with-observables","title":"Enhancing the Template with Observables","text":"<p>The template is updated to bind the form inputs and error messages to the observables:</p> <pre><code>template() {\n  return html`\n    &lt;form action=\"/submit\" method=\"POST\"&gt;\n      &lt;label&gt;\n        Email:\n        &lt;input type=\"email\"\n          aria-invalid=\"\"\n          value=${this.email}&gt;\n        &lt;span&gt;&lt;/span&gt; &lt;!-- Placeholder for email availability message --&gt;\n        &lt;span&gt;${this.emailError}&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;label&gt;\n        Password:\n        &lt;input type=\"password\"\n          value=${this.password}\n          aria-invalid=\"\"&gt;\n        &lt;span&gt;${this.passwordError}&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;input type=\"submit\" value=\"Submit\" disabled&gt;\n    &lt;/form&gt;\n  `;\n}\n</code></pre>"},{"location":"features/streams/#handling-user-input-with-streams","title":"Handling User Input with Streams","text":"<p>Streams are a powerful abstraction for handling a sequence of asynchronous events or data. They represent a set of steps that data passes through, allowing for operations such as mapping, filtering, and debouncing to be applied to the data as it flows through these steps.</p> <p>Here, we initialize two streams to handle user input events for email and password fields. When <code>next(value)</code> is invoked on a stream, the provided value is sent through the defined steps: first to <code>map</code>, then <code>debounce</code>, and finally to <code>subscribe</code> where the actual side effects occur based on the processed data.</p> <pre><code>// ...\nclass FormElement extends ReactiveElement {\n\n// ... other observable definitions\n\nthis.inputValidation$ = this.stream(); // start or root of the stream\nthis.passwordValidation$ = this.stream(); // start or root of the stream\n\nonConnect() {\n  // Define the stream for email input validation\n  this.inputValidation$\n    .map(e =&gt; this.validateEmail(e.target.value)) // Transform the event to validation result\n    .debounce(300) // Wait for 300ms of inactivity before passing the result down the stream\n    .subscribe(({ isEmailValid, emailError, email }) =&gt; {\n      // Update the component state with the validation results\n      this.emailError = emailError;\n      this.isEmailValid = isEmailValid;\n      this.email = email;\n      // Perform an API query to check email availability\n      this.isEmailAvailable = this.queryEmail(this.email);\n    });\n\n  // Define the stream for password input validation\n  this.passwordValidation$\n    .map(e =&gt; this.validatePassword(e.target.value)) // Transform the event to validation result\n    .debounce(300) // Wait for 300ms of inactivity before passing the result down the stream\n    .subscribe(({ isValid, password }) =&gt; {\n      // Update the component state with the validation results\n      this.passwordError = isValid ? '' : 'Password must be at least 8 characters long.';\n      this.password = password;\n    });\n}\n</code></pre> <p>To pass values to the streams, we use the <code>next</code> method provided by the stream (example: <code>this.inputValidation$.next(e)</code>). This next method is called whenever an input event occurs, passing the event into the stream.</p> <p>Below is how we attach the <code>next</code> method to the input event handlers in the template.</p> <pre><code>template() {\n  return html`\n    &lt;form action=\"/submit\" method=\"POST\"&gt;\n      &lt;label&gt;\n        Email:\n        &lt;input type=\"email\"\n          aria-invalid=${this.getEmailInputState()}\n          @input=${(e) =&gt; this.inputValidation$.next(e) } value=${this.email}&gt;\n          &lt;span&gt;${this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length &gt; 0 &amp;&amp; this.emailError === '' ? 'Email is already taken.' : ''}&lt;/span&gt;\n        &lt;span&gt;${this.emailError}&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;label&gt;\n        Password:\n        &lt;input type=\"password\" @input=${(e) =&gt; this.passwordValidation$.next(e) }\n          value=${this.password}\n          aria-invalid=${this.getPasswordInputState()}&gt;\n        &lt;span&gt;${this.passwordError}&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;input type=\"submit\" value=\"Submit\" ?disabled=${this.emailError !== '' || this.passwordError !== '' || this.email === '' || this.password === ''}&gt;\n    &lt;/form&gt;\n  `;\n}\n</code></pre>"},{"location":"features/streams/#validating-email-and-password","title":"Validating Email and Password","text":"<p>The component includes methods to validate the email and password against specific criteria:</p> <pre><code>validateEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  let emailError = '';\n  let isEmailValid = null;\n  if (email === '') {\n    emailError = '';\n    isEmailValid = null;\n  } else if (!emailRegex.test(email)) {\n    emailError = 'Please enter a valid email address.';\n    isEmailValid = false;\n  } else {\n    emailError = '';\n    isEmailValid = true;\n  }\n  return { isEmailValid, emailError, email };\n}\n\nvalidatePassword(password) {\n  let isValid = false;\n  if (password === '') {\n    isValid = null;\n  } else if (password?.length &gt;= 8) {\n    isValid = true;\n  }\n\n  return { isValid, password }\n}\n</code></pre>"},{"location":"features/streams/#querying-email-availability","title":"Querying Email Availability","text":"<p>An API query is performed to check if the entered email is already in use. The <code>query</code> method is part of Cami's asynchronous state management system, which is detailed in async state management. It allows the component to declare a data dependency that is fetched asynchronously, and the component's UI can react to the data, loading, and error states of the query.</p> <pre><code>queryEmail(email) {\n  // Define a query with a unique key and a function to fetch the data\n  return this.query({\n    queryKey: ['Email', email], // The queryKey uniquely identifies this query\n    queryFn: () =&gt; {\n      // Perform a fetch request to check if the email is already in use\n      return fetch(`https://mockend.com/api/kennyfrc/cami-mock-api/users?email_eq=${email}`)\n        .then(res =&gt; res.json());\n    },\n    staleTime: 1000 * 60 * 5 // Data is considered fresh for 5 minutes\n  })\n}\n</code></pre>"},{"location":"features/streams/#updating-the-form-with-validation-and-api-query-results","title":"Updating the Form with Validation and API Query Results","text":"<p>The form is further enhanced to reflect the validation states and API query results, with methods to determine the visual feedback for input fields.</p> <p>There are three states: the base state, the invalid state, and valid state. Let's create methods for those: <code>getEmailInputState()</code> and <code>getPasswordInputState()</code></p> <pre><code>template() {\n  return html`\n    &lt;form action=\"/submit\" method=\"POST\"&gt;\n      &lt;label&gt;\n        Email:\n        &lt;input type=\"email\"\n          aria-invalid=${this.getEmailInputState()}\n          @input=${(e) =&gt; this.inputValidation$.next(e) } value=${this.email}&gt;\n          &lt;span&gt;${this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length &gt; 0 &amp;&amp; this.emailError === '' ? 'Email is already taken.' : ''}&lt;/span&gt;\n        &lt;span&gt;${this.emailError}&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;label&gt;\n        Password:\n        &lt;input type=\"password\" @input=${(e) =&gt; this.passwordValidation$.next(e) }\n          value=${this.password}\n          aria-invalid=${this.getPasswordInputState()}&gt;\n        &lt;span&gt;${this.passwordError}&lt;/span&gt;\n      &lt;/label&gt;\n      &lt;input type=\"submit\" value=\"Submit\" ?disabled=${this.emailError !== '' || this.passwordError !== '' || this.email === '' || this.password === ''}&gt;\n    &lt;/form&gt;\n  `;\n}\n</code></pre> <p>Let's define those here.</p> <pre><code>getEmailInputState() {\n  if (this.email === '') {\n    return '';\n  } else if (this.isEmailValid &amp;&amp; this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length === 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\ngetPasswordInputState() {\n  if (this.password === '') {\n    return '';\n  } else if (this.passwordError === '') {\n    return false;\n  } else {\n    return true;\n  }\n}\n</code></pre> <p>Each step incrementally builds upon the previous one, resulting in a dynamic and responsive form that provides real-time feedback to the user.</p> <p>To review the form again, go here.</p>"},{"location":"learn_by_example/blog/","title":"Blog with Optimistic UI","text":"<p>Our query can also do optimistic UI if:</p> <ul> <li>In the <code>onMutate</code> callback definition, you snapshot the previous state, optimistically update to the new value, and return a rollback function.</li> </ul> <p>HTML:</p> <pre><code>&lt;article&gt;\n  &lt;blog-component-be&gt;&lt;/blog-component-be&gt;\n&lt;/article&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement, http } = cami;\n\n  class BlogComponent extends ReactiveElement {\n    posts = this.query({\n      queryKey: [\"posts\"],\n      queryFn: () =&gt; {\n        return fetch(\"https://jsonplaceholder.typicode.com/posts?_limit=5\")\n          .then(res =&gt; res.json())\n      },\n      staleTime: 1000 * 60 * 5 // 5 minutes\n    })\n\n    //\n    // This uses optimistic UI. To disable optimistic UI, remove the onMutate and onError handlers.\n    //\n    addPost = this.mutation({\n      mutationFn: (newPost) =&gt; {\n        return fetch(\"https://jsonplaceholder.typicode.com/posts\", {\n          method: \"POST\",\n          body: JSON.stringify(newPost),\n          headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n          }\n        }).then(res =&gt; res.json())\n      },\n      onMutate: (newPost) =&gt; {\n        // Snapshot the previous state\n        const previousPosts = this.posts.data;\n\n        // Optimistically update to the new value\n        this.posts.update(state =&gt; {\n          state.data.push({ ...newPost, id: Date.now() });\n        });\n\n        // Return the rollback function and the new post\n        return {\n          rollback: () =&gt; {\n            this.posts.update(state =&gt; {\n              state.data = previousPosts;\n            });\n          },\n          optimisticPost: newPost\n        };\n      },\n      onError: (error, newPost, context) =&gt; {\n        // Rollback to the previous state\n        if (context.rollback) {\n          context.rollback();\n        }\n      },\n      onSettled: () =&gt; {\n        // Invalidate the posts query to refetch the true state\n        if (!this.addPost.isSettled) {\n          this.invalidateQueries(['posts']);\n        }\n      }\n    });\n\n    template() {\n      if (this.addPost.status === \"pending\") {\n        return html`\n        &lt;div class=\"md-loading\"&gt;Adding post...&lt;/div&gt;`;\n      }\n\n      if (this.addPost.status === \"error\") {\n        return html`&lt;div class=\"md-error\"&gt;Error: ${this.addPost.error.message}&lt;/div&gt;`;\n      }\n\n      if (this.posts.data) {\n        return html`\n          &lt;button class=\"md-button\" @click=${() =&gt; this.addPost.mutate({\n            title: \"New Post, Made Optimistically\",\n            body: \"This is a new post created with optimistic UI. I actually won't persist to the server though. So upon refresh, I will rollback (either through window change, refresh, or after stale time of 5 minutes)\",\n            userId: 1\n          })}&gt;Add Post&lt;/button&gt;\n          &lt;ul class=\"md-list\"&gt;\n            ${this.posts.data.slice().reverse().map(post =&gt; html`\n              &lt;li class=\"md-list-item\"&gt;\n                &lt;h2 class=\"md-title\"&gt;${post.title}&lt;/h2&gt;\n                &lt;p class=\"md-body\"&gt;${post.body}&lt;/p&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        `;\n      }\n\n      if (this.posts.status === \"loading\") {\n        return html`&lt;div class=\"md-loading\"&gt;Loading...&lt;/div&gt;`;\n      }\n\n      if (this.posts.status === \"error\") {\n        return html`&lt;div class=\"md-error\"&gt;Error: ${this.posts.error.message}&lt;/div&gt;`;\n      }\n    }\n  }\n\n\n  customElements.define('blog-component-be', BlogComponent);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/cart/","title":"Shopping Cart with Server &amp; Client State","text":"Products <p>This fetches the products from an API, and uses a client-side store to manage the cart. After adding a product to the cart, you can refresh the page and the cart will still be there as we are persisting the cart to localStorage, which is what you want in a cart.</p> Product List Cart <p>HTML:</p> <pre><code>&lt;article&gt;\n  &lt;h4&gt;Products&lt;/h4&gt;\n  &lt;p&gt;This fetches the products from an API, and uses a client-side store to manage the cart. After adding a product to the cart, you can refresh the page and the cart will still be there as we are persisting the cart to localStorage, which is what you want in a cart.&lt;/p&gt;\n  &lt;h5&gt;Product List&lt;/h5&gt;\n  &lt;product-list-cami-example-be&gt;&lt;/product-list-cami-example-be&gt;\n&lt;/article&gt;\n&lt;article&gt;\n  &lt;h4&gt;Cart&lt;/h4&gt;\n  &lt;cart-cami-example&gt;&lt;/cart-cami-example&gt;\n&lt;/article&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  const CartStore = cami.store({\n    cartItems: [],\n    add: (store, product) =&gt; {\n      const cartItem = { ...product, cartItemId: Date.now() };\n      store.cartItems.push(cartItem);\n    },\n    remove: (store, product) =&gt; {\n      store.cartItems = store.cartItems.filter(item =&gt; item.cartItemId !== product.cartItemId);\n    }\n  }, {name: 'CartStore', expiry: 1000 * 60 * 60 * 24 * 3}); // 3 days\n  // CartStore.reset() // if for some reason, you want to reset the store\n\n  // Define a middleware function\n  const loggerMiddleware = (context) =&gt; {\n    console.log(`Action ${context.action} was dispatched with payload:`, context.payload);\n  };\n\n  // Use the middleware function with the initialState\n  CartStore.use(loggerMiddleware);\n\n  class ProductListElement extends ReactiveElement {\n    cartItems = this.connect(CartStore, 'cartItems');\n    products = this.query({\n      queryKey: ['products'],\n      queryFn: () =&gt; {\n        return fetch(\"https://mockend.com/api/kennyfrc/cami-mock-api/products?limit=3\").then(res =&gt; res.json())\n      },\n      staleTime: 1000 * 60 * 5 // 5 minutes\n    });\n\n    addToCart(product) {\n      CartStore.add(product);\n    }\n\n    isProductInCart(product) {\n      return this.cartItems ? this.cartItems.some(item =&gt; item.id === product.id) : false;\n    }\n\n    isOutOfStock(product) {\n      return product.stock === 0;\n    }\n\n    template() {\n      if (this.products.status === \"pending\") {\n        return html`&lt;div&gt;Loading...&lt;/div&gt;`;\n      }\n\n      if (this.products.status === \"error\") {\n        return html`&lt;div&gt;Error: ${this.products.error.message}&lt;/div&gt;`;\n      }\n\n      if (this.products.data) {\n        return html`\n          &lt;ul&gt;\n            ${this.products.data.map(product =&gt; html`\n              &lt;li&gt;\n                ${product.name} - $${(product.price / 100).toFixed(2)}\n                &lt;button class=\"md-button md-small\" @click=${() =&gt; this.addToCart(product)} ?disabled=${this.isOutOfStock(product)}&gt;\n                  Add to cart\n                &lt;/button&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        `;\n      }\n    }\n  }\n\n  customElements.define('product-list-cami-example-be', ProductListElement);\n\n  class CartElement extends ReactiveElement {\n    cartItems = this.connect(CartStore, 'cartItems');\n\n    get cartValue() {\n      return this.cartItems.reduce((acc, item) =&gt; acc + item.price, 0);\n    }\n\n    removeFromCart(product) {\n      CartStore.remove(product);\n    }\n\n    template() {\n      return html`\n        &lt;p&gt;Note: Refresh the page to see that the cart is persisted to localStorage. You can also look at &lt;code&gt;Chrome DevTools &gt; Application &gt; Local Storage&lt;/code&gt; to see the cart items.&lt;/p&gt;\n        &lt;p&gt;Cart value: $${(this.cartValue / 100).toFixed(2)}&lt;/p&gt;\n        &lt;ul&gt;\n          ${this.cartItems.map(item =&gt; html`\n            &lt;li&gt;${item.name} - $${(item.price / 100).toFixed(2)} &lt;button class=\"md-button md-small\" @click=${() =&gt; this.removeFromCart(item)}&gt;Remove&lt;/button&gt;&lt;/li&gt;\n          `)}\n        &lt;/ul&gt;\n      `;\n    }\n  }\n\n  customElements.define('cart-cami-example', CartElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/counter/","title":"Simple Counter","text":""},{"location":"learn_by_example/counter/#html","title":"HTML","text":"<pre><code>&lt;article&gt;\n  &lt;h1&gt;Counter&lt;/h1&gt;\n  &lt;counter-component-be\n  &gt;&lt;/counter-component-be&gt;\n&lt;/article&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class CounterElement extends ReactiveElement {\n    count = 0\n\n    template() {\n      return html`\n        &lt;button class=\"md-button\" @click=${() =&gt; this.count--}&gt;-&lt;/button&gt;\n        &lt;button class=\"md-button\" @click=${() =&gt; this.count++}&gt;+&lt;/button&gt;\n        &lt;div&gt;Count: ${this.count}&lt;/div&gt;\n      `;\n    }\n  }\n\n  customElements.define('counter-component-be', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/counter_interval/","title":"Counter with Interval","text":"<p>For formulas (e.g. doubling), it's best to use getter methods. If you're familiar with <code>computeds</code>, I'd say that this functions in a similar way, where the <code>doubleCount</code> variable is updated lazily.</p> <p>This also demonstrates effects, which you can see in the console.</p> <pre><code>&lt;article&gt;\n  &lt;h1&gt;Counter with Interval&lt;/h1&gt;\n  &lt;counter-component&gt;&lt;/counter-component&gt;\n&lt;/article&gt;\n&lt;script src=\"./build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;!-- CDN version below --&gt;\n&lt;!-- &lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt; --&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\nclass CounterElement extends ReactiveElement {\n  count = 0;\n\n  get doubleCount() {\n    return this.count * 2;\n  }\n\n  onConnect() {\n    setInterval(() =&gt; this.count++, 1000);\n    this.effect(() =&gt; {\n      console.log(`Count: ${this.count}`);\n    });\n    this.effect(() =&gt; {\n      console.log(`Double Count: ${this.doubleCount}`);\n    });\n  }\n\n  template() {\n    return html`\n      &lt;div&gt;Double Count: ${this.doubleCount}&lt;/div&gt;\n    `;\n  }\n}\n\ncustomElements.define('counter-component', CounterElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/data_props/","title":"Task Manager (Attribute Data)","text":"<p>If you somehow need to define data in the web components attribute (perhaps its easier in your server-side templating language), you can do so with <code>observableAttributes</code>. You can pass a parsing function to that.</p> <pre><code>&lt;task-manager-props-be\n    todos='{\"data\": [\"Buy milk\", \"Buy eggs\", \"Buy bread\"]}'\n  &gt;&lt;/task-manager-props-be&gt;\n</code></pre> <p>HTML:</p> <pre><code>&lt;article&gt;\n&lt;task-manager-props-be\n    todos='{\"data\": [\"Buy milk\", \"Buy eggs\", \"Buy bread\"]}'\n  &gt;&lt;/task-manager-props-be&gt;\n&lt;/article&gt;\n&lt;script src=\"./build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;!-- CDN version below --&gt;\n&lt;!-- &lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt; --&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class MyComponent extends ReactiveElement {\n    todos = []\n\n    onConnect() {\n      this.observableAttributes({\n        todos: (v) =&gt; JSON.parse(v).data\n      });\n    }\n\n    addTodo (todo) {\n      this.todos.push(todo);\n    }\n\n    deleteTodo (todo) {\n      this.todos.splice(this.todos.indexOf(todo), 1);\n    }\n\n    template() {\n      return html`\n        &lt;input id=\"newTodo\" type=\"text\" class=\"md-input\" placeholder=\"Add Task\" /&gt;\n        &lt;button class=\"md-button\" @click=${() =&gt; {\n          this.addTodo(document.getElementById('newTodo').value); document.getElementById('newTodo').value = ''; }}\n        &gt;Add&lt;/button&gt;\n        &lt;ul class=\"md-list\"&gt;\n          ${this.todos.map(todo =&gt; html`\n            &lt;li class=\"md-list-item\"&gt;\n              ${todo}\n              &lt;button class=\"md-button md-small\" @click=${() =&gt; this.deleteTodo(todo)\n              }&gt;Delete&lt;/button&gt;\n            &lt;/li&gt;\n          `)}\n        &lt;/ul&gt;\n      `;\n    }\n\n  }\n\n  customElements.define('task-manager-props-be', MyComponent);\n\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/form_validation/","title":"Interactive Registration Form","text":"Try entering an email that is already taken, such as geovanniheaney@block.info (this is a mock email in our API) <p> <p></p> <p>HTML:</p> <pre><code>&lt;article&gt;\n  &lt;small&gt;Try entering an email that is already taken, such as geovanniheaney@block.info (this is a mock email in our API)&lt;/small&gt;\n  &lt;registration-form-cami-example-be&gt;&lt;/registration-form-cami-example-be&gt;\n&lt;/article&gt;\n&lt;small&gt;\n\n&lt;/small&gt;\n&lt;!-- CDN version below --&gt;\n&lt;!-- &lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt; --&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class FormElement extends ReactiveElement {\n    emailError = ''\n    passwordError = ''\n    email = '';\n    password = '';\n    emailIsValid = null;\n    isEmailAvailable = null;\n\n    inputValidation$ = this.stream();\n    passwordValidation$ = this.stream();\n\n    onConnect() {\n      this.inputValidation$\n        .map(e =&gt; this.validateEmail(e.target.value))\n        .debounce(300)\n        .subscribe(({ isEmailValid, emailError, email }) =&gt; {\n          this.emailError = emailError;\n          this.isEmailValid = isEmailValid;\n          this.email = email;\n          this.isEmailAvailable = this.queryEmail(this.email)\n        });\n\n      this.passwordValidation$\n        .map(e =&gt; this.validatePassword(e.target.value))\n        .debounce(300)\n        .subscribe(({ isValid, password }) =&gt; {\n          this.passwordError = isValid ? '' : 'Password must be at least 8 characters long.';\n          this.password = password;\n        });\n    }\n\n    validateEmail(email) {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      let emailError = '';\n      let isEmailValid = null;\n      if (email === '') {\n        emailError = '';\n        isEmailValid = null;\n      } else if (!emailRegex.test(email)) {\n        emailError = 'Please enter a valid email address.';\n        isEmailValid = false;\n      } else {\n        emailError = '';\n        isEmailValid = true;\n      }\n      return { isEmailValid, emailError, email };\n    }\n\n    validatePassword(password) {\n      let isValid = false;\n      if (password === '') {\n        isValid = null;\n      } else if (password?.length &gt;= 8) {\n        isValid = true;\n      }\n\n      return { isValid, password }\n    }\n\n    queryEmail(email) {\n      return this.query({\n        queryKey: ['Email', email],\n        queryFn: () =&gt; {\n          return fetch(`https://mockend.com/api/kennyfrc/cami-mock-api/users?email_eq=${email}`).then(res =&gt; res.json())\n        },\n        staleTime: 1000 * 60 * 5\n      })\n    }\n\n    getEmailInputState() {\n      if (this.email === '') {\n        return '';\n      } else if (this.isEmailValid &amp;&amp; this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length === 0) {\n        return 'valid';\n      } else {\n        return 'invalid';\n      }\n    }\n\n    getPasswordInputState() {\n      if (this.password === '') {\n        return '';\n      } else if (this.passwordError === '') {\n        return 'valid';\n      } else {\n        return 'invalid';\n      }\n    }\n\n    template() {\n      return html`\n        &lt;style&gt;\n          .md-input.invalid {\n            border: 2px solid red;\n            border-bottom: 2px solid red !important; /* Override Material blue bottom border */\n            transition: border-color 0.1s ease-in-out;\n          }\n          .md-input.valid {\n            border: 2px solid green;\n            border-bottom: 2px solid green !important; /* Override Material blue bottom border */\n            transition: border-color 0.1s ease-in-out;\n          }\n          .md-input {\n            border-bottom: 1px solid #ccc !important; /* Override Material blue bottom border */\n            border: 1px solid #ccc;\n            transition: border-color 0.1s ease-in-out;\n            margin-top: 8px;\n            margin-bottom: 8px;\n          }\n          .md-button:disabled {\n            opacity: 0.5;\n            cursor: not-allowed;\n            transition: opacity 0.1s ease-in-out;\n          }\n        &lt;/style&gt;\n        &lt;form action=\"/submit\" method=\"POST\" class=\"md-form\"&gt;\n          &lt;div class=\"md-form-group\"&gt;\n            &lt;label&gt;Email:&lt;/label&gt;\n            &lt;input type=\"email\"\n              class=\"md-input ${this.getEmailInputState()}\"\n              @input=${(e) =&gt; this.inputValidation$.next(e)} value=${this.email}&gt;\n            &lt;span&gt;${this.isEmailAvailable?.status === 'success' &amp;&amp; this.isEmailAvailable?.data?.length &gt; 0 &amp;&amp; this.emailError === '' ? 'Email is already taken.' : ''}&lt;/span&gt;\n            &lt;span&gt;${this.emailError}&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div class=\"md-form-group\"&gt;\n            &lt;label&gt;Password:&lt;/label&gt;\n            &lt;input type=\"password\"\n              class=\"md-input ${this.getPasswordInputState()}\"\n              @input=${(e) =&gt; this.passwordValidation$.next(e)}\n              value=${this.password}&gt;\n            &lt;span&gt;${this.passwordError}&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div class=\"md-form-group\"&gt;\n            &lt;input type=\"submit\" class=\"md-button md-button--primary\" value=\"Submit\"\n              ?disabled=${this.emailError !== '' || this.passwordError !== '' || this.email === '' || this.password === ''}&gt;\n          &lt;/div&gt;\n        &lt;/form&gt;\n      `;\n    }\n  }\n\n  customElements.define('registration-form-cami-example-be', FormElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/nested_updates/","title":"Nested Updates","text":"<p>For deeply nested data, you can use the <code>update</code> method to update the data. This is useful for when you want to update a deeply nested property, but don't want to have to reassign the entire object.</p> User Info with Deeply Nested Data <p>HTML:</p> <pre><code>&lt;article&gt;\n  &lt;h5&gt;User Info with Deeply Nested Data&lt;/h5&gt;\n  &lt;nested-data-be&gt;&lt;/nested-data-be&gt;\n&lt;/article&gt;\n&lt;script src=\"./build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;!-- CDN version below --&gt;\n&lt;!-- &lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt; --&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class NestedObservableElement extends ReactiveElement {\n    user = {\n      name: 'John',\n      age: 30,\n      address: {\n        street: '123 Main St',\n        city: 'Anytown',\n        country: 'USA',\n        postalCode: '12345',\n        coordinates: {\n          lat: '40.7128',\n          long: '74.0060'\n        }\n      }\n    };\n\n    changeUser() {\n      const john = {\n        name: 'John',\n        age: 30,\n        address: {\n          street: '123 Main St',\n          city: 'Anytown',\n          country: 'USA',\n          postalCode: '12345',\n          coordinates: {\n            lat: '40.7128',\n            long: '74.0060'\n          }\n        }\n      };\n\n      const jane = {\n        name: 'Jane',\n        age: 31,\n        address: {\n          street: '456 Elm St',\n          city: 'Othertown',\n          country: 'Canada',\n          postalCode: '67890',\n          coordinates: {\n            lat: '51.5074',\n            long: '0.1278'\n          }\n        }\n      };\n\n      this.user = (this.user.name == 'John') ? jane : john;\n    }\n\n    changeName() {\n      this.user.update(user =&gt; {\n        user.name = (user.name == 'John') ? 'Jane' : 'John';\n      });\n    }\n\n    changeStreet() {\n      this.user.update(user =&gt; {\n        user.address.street = (user.address.street == '123 Main St') ? '456 Elm St' : '123 Main St';\n      });\n    }\n\n    changeLat() {\n      this.user.update(user =&gt; {\n        user.address.coordinates.lat = (user.address.coordinates.lat == '40.7128') ? '51.5074' : '40.7128';\n      });\n    }\n\n    template() {\n      return html`\n        &lt;div class=\"md-typography--body1\"&gt;Name: ${this.user.name}&lt;/div&gt;\n        &lt;div class=\"md-typography--body1\"&gt;Street: ${this.user.address.street}&lt;/div&gt;\n        &lt;div class=\"md-typography--body1\"&gt;Latitude: ${this.user.address.coordinates.lat}&lt;/div&gt;\n        &lt;button class=\"md-button\" @click=${() =&gt; this.changeUser()}&gt;Change User&lt;/button&gt;\n        &lt;button class=\"md-button\" @click=${() =&gt; this.changeName()}&gt;Change Name&lt;/button&gt;\n        &lt;button class=\"md-button\" @click=${() =&gt; this.changeStreet()}&gt;Change Street&lt;/button&gt;\n        &lt;button class=\"md-button\" @click=${() =&gt; this.changeLat()}&gt;Change Latitude&lt;/button&gt;\n      `;\n    }\n  }\n\n  customElements.define('nested-data-be', NestedObservableElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/simple_task_manager/","title":"Simple Task Manager","text":"<p>Just in-memory state. Good example for learning the basic workings of cami.</p> <p>HTML:</p> <pre><code>&lt;article&gt;\n  &lt;task-manager-component-be&gt;&lt;/task-manager-component-be&gt;\n&lt;/article&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement } = cami;\n\n  class TaskManagerElement extends ReactiveElement {\n    tasks = [];\n    filter = 'all';\n\n    addTask(task) {\n      this.tasks.push({ name: task, completed: false });\n    }\n\n    removeTask(index) {\n      this.tasks.splice(index, 1);\n    }\n\n    toggleTask(index) {\n      this.tasks.update(tasks =&gt; {\n        tasks[index].completed = !tasks[index].completed;\n      });\n    }\n\n    setFilter(filter) {\n      this.filter = filter;\n    }\n\n    getFilteredTasks() {\n      switch (this.filter) {\n        case 'completed':\n          return this.tasks.filter(task =&gt; task.completed);\n        case 'active':\n          return this.tasks.filter(task =&gt; !task.completed);\n        default:\n          return this.tasks;\n      }\n    }\n\n    template() {\n      return html`\n        &lt;div class=\"md-form-group\"&gt;\n          &lt;input id=\"taskInput\" class=\"md-input\" type=\"text\" placeholder=\"Enter task name\"&gt;\n          &lt;button class=\"md-button\" @click=${() =&gt; {\n            this.addTask(document.getElementById('taskInput').value);\n            document.getElementById('taskInput').value = '';\n          }}&gt;Add Task&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;div class=\"md-button-group\"&gt;\n          &lt;button class=\"md-button\" @click=${() =&gt; this.setFilter('all')}&gt;All&lt;/button&gt;\n          &lt;button class=\"md-button\" @click=${() =&gt; this.setFilter('active')}&gt;Active&lt;/button&gt;\n          &lt;button class=\"md-button\" @click=${() =&gt; this.setFilter('completed')}&gt;Completed&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;ul class=\"md-list\"&gt;\n          ${this.getFilteredTasks().map((task, index) =&gt; html`\n            &lt;li class=\"md-list-item\"&gt;\n              &lt;input class=\"md-checkbox\" type=\"checkbox\" .checked=${task.completed} @click=${() =&gt; this.toggleTask(index)}&gt;\n              &lt;span class=\"md-text\"&gt;${task.name}&lt;/span&gt;\n              &lt;a class=\"md-link\" @click=${() =&gt; this.removeTask(index)}&gt;Remove&lt;/a&gt;\n            &lt;/li&gt;\n          `)}\n        &lt;/ul&gt;\n      `;\n    }\n  }\n\n  customElements.define('task-manager-component-be', TaskManagerElement);\n&lt;/script&gt;\n</code></pre>"},{"location":"learn_by_example/todo_list/","title":"Todo List with Server State","text":"<p>HTML:</p> <pre><code>&lt;article&gt;\n  &lt;todo-list-component-be&gt;&lt;/todo-list-component-be&gt;\n&lt;/article&gt;\n&lt;script src=\"./build/cami.cdn.js\"&gt;&lt;/script&gt;\n&lt;!-- CDN version below --&gt;\n&lt;!-- &lt;script src=\"https://unpkg.com/cami@latest/build/cami.cdn.js\"&gt;&lt;/script&gt; --&gt;\n&lt;script type=\"module\"&gt;\n  const { html, ReactiveElement, http } = cami;\n\n  class TodoListElement extends ReactiveElement {\n    todos = this.query({\n      queryKey: ['todos'],\n      queryFn: () =&gt; {\n        return fetch(\"https://mockend.com/api/kennyfrc/cami-mock-api/todos?limit=5\").then(res =&gt; res.json())\n      },\n      staleTime: 1000 * 60 * 5 // 5 minutes\n    })\n\n    addTodo = this.mutation({\n      mutationFn: (newTodo) =&gt; {\n        return fetch(\"https://mockend.com/api/kennyfrc/cami-mock-api/todos\", {\n          method: \"POST\",\n          body: JSON.stringify(newTodo),\n          headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n          }\n        }).then(res =&gt; {\n          document.querySelector('.note').innerHTML = 'Todo was dispatched to the server. Since we are using a mock API, this wont work. In your server environment, you would need to persist the changes to your server database. The query will automatically refetch the data from the server.';\n          return res.json();\n        })\n      }\n    });\n\n    deleteTodo = this.mutation({\n      mutationFn: (todo) =&gt; {\n        return fetch(`https://mockend.com/api/kennyfrc/cami-mock-api/todos/${todo.id}`, {\n          method: \"DELETE\"\n        }).then(res =&gt; {\n          document.querySelector('.note').innerHTML = 'Todo was deleted from the server. Since we are using a mock API, this wont work. In your server environment, you would need to persist the changes to your server database. The query will automatically refetch the data from the server.';\n          return res.json();\n        })\n      }\n    });\n\n    template() {\n      if (this.addTodo.status === \"pending\") {\n        return html`\n          &lt;li class=\"md-opacity-50\"&gt;\n            Adding new todo...\n          &lt;/li&gt;\n        `;\n      }\n\n      if (this.deleteTodo.status === \"pending\") {\n        return html`\n          &lt;li class=\"md-opacity-50\"&gt;\n            Deleting todo...\n          &lt;/li&gt;\n        `;\n      }\n\n      if (this.todos.data) {\n        return html`\n          &lt;input class=\"newTodo md-input\" type=\"text\" /&gt;\n          &lt;button class=\"md-button\" @click=${() =&gt; {\n            const input = document.querySelector('.newTodo');\n            const newTodoTitle = input.value;\n            input.value = ''; // Clear the input after getting the value\n            this.addTodo.mutate({\n              title: newTodoTitle,\n              completed: false\n            })\n          }}&gt;Add&lt;/button&gt;\n          &lt;ul&gt;\n            ${this.todos.data.slice().reverse().map(todo =&gt; html`\n              &lt;li class=\"md-list-item\"&gt;\n                ${todo.title}\n                &lt;button class=\"md-button\" @click=${() =&gt; this.deleteTodo.mutate(todo)}&gt;Delete&lt;/button&gt;\n              &lt;/li&gt;\n            `)}\n          &lt;/ul&gt;\n        `;\n      }\n\n      if (this.todos.status === \"pending\") {\n        return html`&lt;div class=\"md-loading\"&gt;Loading...&lt;/div&gt;`;\n      }\n\n      if (this.todos.status === \"error\") {\n        return html`&lt;div class=\"md-error\"&gt;Error: ${this.todos.error.message}&lt;/div&gt;`;\n      }\n\n      if (this.addTodo.status === \"error\") {\n        return html`&lt;div class=\"md-error\"&gt;Error: ${this.addTodo.error.message}&lt;/div&gt;`;\n      }\n    }\n  }\n\n  customElements.define('todo-list-component-be', TodoListElement);\n&lt;/script&gt;\n</code></pre>"}]}